// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages-bitcoin.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "messages-bitcoin.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace {

const ::google::protobuf::Descriptor* MultisigRedeemScriptType_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MultisigRedeemScriptType_reflection_ = NULL;
const ::google::protobuf::Descriptor* MultisigRedeemScriptType_HDNodePathType_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MultisigRedeemScriptType_HDNodePathType_reflection_ = NULL;
const ::google::protobuf::Descriptor* GetPublicKey_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GetPublicKey_reflection_ = NULL;
const ::google::protobuf::Descriptor* PublicKey_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PublicKey_reflection_ = NULL;
const ::google::protobuf::Descriptor* GetAddress_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GetAddress_reflection_ = NULL;
const ::google::protobuf::Descriptor* Address_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Address_reflection_ = NULL;
const ::google::protobuf::Descriptor* SignMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SignMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* MessageSignature_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MessageSignature_reflection_ = NULL;
const ::google::protobuf::Descriptor* VerifyMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  VerifyMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* SignTx_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SignTx_reflection_ = NULL;
const ::google::protobuf::Descriptor* TxRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TxRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* TxRequest_TxRequestDetailsType_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TxRequest_TxRequestDetailsType_reflection_ = NULL;
const ::google::protobuf::Descriptor* TxRequest_TxRequestSerializedType_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TxRequest_TxRequestSerializedType_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* TxRequest_RequestType_descriptor_ = NULL;
const ::google::protobuf::Descriptor* TxAck_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TxAck_reflection_ = NULL;
const ::google::protobuf::Descriptor* TxAck_TransactionType_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TxAck_TransactionType_reflection_ = NULL;
const ::google::protobuf::Descriptor* TxAck_TransactionType_TxInputType_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TxAck_TransactionType_TxInputType_reflection_ = NULL;
const ::google::protobuf::Descriptor* TxAck_TransactionType_TxOutputBinType_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TxAck_TransactionType_TxOutputBinType_reflection_ = NULL;
const ::google::protobuf::Descriptor* TxAck_TransactionType_TxOutputType_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TxAck_TransactionType_TxOutputType_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* TxAck_TransactionType_TxOutputType_OutputScriptType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* InputScriptType_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_messages_2dbitcoin_2eproto() {
  protobuf_AddDesc_messages_2dbitcoin_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "messages-bitcoin.proto");
  GOOGLE_CHECK(file != NULL);
  MultisigRedeemScriptType_descriptor_ = file->message_type(0);
  static const int MultisigRedeemScriptType_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MultisigRedeemScriptType, pubkeys_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MultisigRedeemScriptType, signatures_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MultisigRedeemScriptType, m_),
  };
  MultisigRedeemScriptType_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MultisigRedeemScriptType_descriptor_,
      MultisigRedeemScriptType::default_instance_,
      MultisigRedeemScriptType_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MultisigRedeemScriptType, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MultisigRedeemScriptType, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MultisigRedeemScriptType));
  MultisigRedeemScriptType_HDNodePathType_descriptor_ = MultisigRedeemScriptType_descriptor_->nested_type(0);
  static const int MultisigRedeemScriptType_HDNodePathType_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MultisigRedeemScriptType_HDNodePathType, node_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MultisigRedeemScriptType_HDNodePathType, address_n_),
  };
  MultisigRedeemScriptType_HDNodePathType_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MultisigRedeemScriptType_HDNodePathType_descriptor_,
      MultisigRedeemScriptType_HDNodePathType::default_instance_,
      MultisigRedeemScriptType_HDNodePathType_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MultisigRedeemScriptType_HDNodePathType, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MultisigRedeemScriptType_HDNodePathType, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MultisigRedeemScriptType_HDNodePathType));
  GetPublicKey_descriptor_ = file->message_type(1);
  static const int GetPublicKey_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetPublicKey, address_n_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetPublicKey, ecdsa_curve_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetPublicKey, show_display_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetPublicKey, coin_name_),
  };
  GetPublicKey_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GetPublicKey_descriptor_,
      GetPublicKey::default_instance_,
      GetPublicKey_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetPublicKey, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetPublicKey, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GetPublicKey));
  PublicKey_descriptor_ = file->message_type(2);
  static const int PublicKey_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PublicKey, node_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PublicKey, xpub_),
  };
  PublicKey_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PublicKey_descriptor_,
      PublicKey::default_instance_,
      PublicKey_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PublicKey, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PublicKey, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PublicKey));
  GetAddress_descriptor_ = file->message_type(3);
  static const int GetAddress_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetAddress, address_n_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetAddress, coin_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetAddress, show_display_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetAddress, multisig_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetAddress, script_type_),
  };
  GetAddress_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GetAddress_descriptor_,
      GetAddress::default_instance_,
      GetAddress_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetAddress, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetAddress, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GetAddress));
  Address_descriptor_ = file->message_type(4);
  static const int Address_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Address, address_),
  };
  Address_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Address_descriptor_,
      Address::default_instance_,
      Address_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Address, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Address, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Address));
  SignMessage_descriptor_ = file->message_type(5);
  static const int SignMessage_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignMessage, address_n_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignMessage, message_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignMessage, coin_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignMessage, script_type_),
  };
  SignMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SignMessage_descriptor_,
      SignMessage::default_instance_,
      SignMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SignMessage));
  MessageSignature_descriptor_ = file->message_type(6);
  static const int MessageSignature_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MessageSignature, address_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MessageSignature, signature_),
  };
  MessageSignature_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MessageSignature_descriptor_,
      MessageSignature::default_instance_,
      MessageSignature_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MessageSignature, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MessageSignature, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MessageSignature));
  VerifyMessage_descriptor_ = file->message_type(7);
  static const int VerifyMessage_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VerifyMessage, address_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VerifyMessage, signature_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VerifyMessage, message_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VerifyMessage, coin_name_),
  };
  VerifyMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      VerifyMessage_descriptor_,
      VerifyMessage::default_instance_,
      VerifyMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VerifyMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VerifyMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(VerifyMessage));
  SignTx_descriptor_ = file->message_type(8);
  static const int SignTx_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignTx, outputs_count_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignTx, inputs_count_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignTx, coin_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignTx, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignTx, lock_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignTx, expiry_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignTx, overwintered_),
  };
  SignTx_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SignTx_descriptor_,
      SignTx::default_instance_,
      SignTx_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignTx, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignTx, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SignTx));
  TxRequest_descriptor_ = file->message_type(9);
  static const int TxRequest_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxRequest, request_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxRequest, details_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxRequest, serialized_),
  };
  TxRequest_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TxRequest_descriptor_,
      TxRequest::default_instance_,
      TxRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxRequest, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxRequest, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TxRequest));
  TxRequest_TxRequestDetailsType_descriptor_ = TxRequest_descriptor_->nested_type(0);
  static const int TxRequest_TxRequestDetailsType_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxRequest_TxRequestDetailsType, request_index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxRequest_TxRequestDetailsType, tx_hash_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxRequest_TxRequestDetailsType, extra_data_len_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxRequest_TxRequestDetailsType, extra_data_offset_),
  };
  TxRequest_TxRequestDetailsType_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TxRequest_TxRequestDetailsType_descriptor_,
      TxRequest_TxRequestDetailsType::default_instance_,
      TxRequest_TxRequestDetailsType_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxRequest_TxRequestDetailsType, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxRequest_TxRequestDetailsType, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TxRequest_TxRequestDetailsType));
  TxRequest_TxRequestSerializedType_descriptor_ = TxRequest_descriptor_->nested_type(1);
  static const int TxRequest_TxRequestSerializedType_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxRequest_TxRequestSerializedType, signature_index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxRequest_TxRequestSerializedType, signature_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxRequest_TxRequestSerializedType, serialized_tx_),
  };
  TxRequest_TxRequestSerializedType_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TxRequest_TxRequestSerializedType_descriptor_,
      TxRequest_TxRequestSerializedType::default_instance_,
      TxRequest_TxRequestSerializedType_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxRequest_TxRequestSerializedType, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxRequest_TxRequestSerializedType, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TxRequest_TxRequestSerializedType));
  TxRequest_RequestType_descriptor_ = TxRequest_descriptor_->enum_type(0);
  TxAck_descriptor_ = file->message_type(10);
  static const int TxAck_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxAck, tx_),
  };
  TxAck_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TxAck_descriptor_,
      TxAck::default_instance_,
      TxAck_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxAck, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxAck, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TxAck));
  TxAck_TransactionType_descriptor_ = TxAck_descriptor_->nested_type(0);
  static const int TxAck_TransactionType_offsets_[11] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxAck_TransactionType, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxAck_TransactionType, inputs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxAck_TransactionType, bin_outputs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxAck_TransactionType, lock_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxAck_TransactionType, outputs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxAck_TransactionType, inputs_cnt_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxAck_TransactionType, outputs_cnt_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxAck_TransactionType, extra_data_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxAck_TransactionType, extra_data_len_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxAck_TransactionType, expiry_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxAck_TransactionType, overwintered_),
  };
  TxAck_TransactionType_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TxAck_TransactionType_descriptor_,
      TxAck_TransactionType::default_instance_,
      TxAck_TransactionType_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxAck_TransactionType, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxAck_TransactionType, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TxAck_TransactionType));
  TxAck_TransactionType_TxInputType_descriptor_ = TxAck_TransactionType_descriptor_->nested_type(0);
  static const int TxAck_TransactionType_TxInputType_offsets_[12] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxAck_TransactionType_TxInputType, address_n_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxAck_TransactionType_TxInputType, prev_hash_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxAck_TransactionType_TxInputType, prev_index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxAck_TransactionType_TxInputType, script_sig_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxAck_TransactionType_TxInputType, sequence_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxAck_TransactionType_TxInputType, script_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxAck_TransactionType_TxInputType, multisig_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxAck_TransactionType_TxInputType, amount_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxAck_TransactionType_TxInputType, decred_tree_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxAck_TransactionType_TxInputType, decred_script_version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxAck_TransactionType_TxInputType, prev_block_hash_bip115_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxAck_TransactionType_TxInputType, prev_block_height_bip115_),
  };
  TxAck_TransactionType_TxInputType_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TxAck_TransactionType_TxInputType_descriptor_,
      TxAck_TransactionType_TxInputType::default_instance_,
      TxAck_TransactionType_TxInputType_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxAck_TransactionType_TxInputType, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxAck_TransactionType_TxInputType, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TxAck_TransactionType_TxInputType));
  TxAck_TransactionType_TxOutputBinType_descriptor_ = TxAck_TransactionType_descriptor_->nested_type(1);
  static const int TxAck_TransactionType_TxOutputBinType_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxAck_TransactionType_TxOutputBinType, amount_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxAck_TransactionType_TxOutputBinType, script_pubkey_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxAck_TransactionType_TxOutputBinType, decred_script_version_),
  };
  TxAck_TransactionType_TxOutputBinType_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TxAck_TransactionType_TxOutputBinType_descriptor_,
      TxAck_TransactionType_TxOutputBinType::default_instance_,
      TxAck_TransactionType_TxOutputBinType_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxAck_TransactionType_TxOutputBinType, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxAck_TransactionType_TxOutputBinType, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TxAck_TransactionType_TxOutputBinType));
  TxAck_TransactionType_TxOutputType_descriptor_ = TxAck_TransactionType_descriptor_->nested_type(2);
  static const int TxAck_TransactionType_TxOutputType_offsets_[9] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxAck_TransactionType_TxOutputType, address_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxAck_TransactionType_TxOutputType, address_n_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxAck_TransactionType_TxOutputType, amount_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxAck_TransactionType_TxOutputType, script_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxAck_TransactionType_TxOutputType, multisig_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxAck_TransactionType_TxOutputType, op_return_data_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxAck_TransactionType_TxOutputType, decred_script_version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxAck_TransactionType_TxOutputType, block_hash_bip115_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxAck_TransactionType_TxOutputType, block_height_bip115_),
  };
  TxAck_TransactionType_TxOutputType_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TxAck_TransactionType_TxOutputType_descriptor_,
      TxAck_TransactionType_TxOutputType::default_instance_,
      TxAck_TransactionType_TxOutputType_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxAck_TransactionType_TxOutputType, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxAck_TransactionType_TxOutputType, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TxAck_TransactionType_TxOutputType));
  TxAck_TransactionType_TxOutputType_OutputScriptType_descriptor_ = TxAck_TransactionType_TxOutputType_descriptor_->enum_type(0);
  InputScriptType_descriptor_ = file->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_messages_2dbitcoin_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MultisigRedeemScriptType_descriptor_, &MultisigRedeemScriptType::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MultisigRedeemScriptType_HDNodePathType_descriptor_, &MultisigRedeemScriptType_HDNodePathType::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GetPublicKey_descriptor_, &GetPublicKey::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PublicKey_descriptor_, &PublicKey::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GetAddress_descriptor_, &GetAddress::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Address_descriptor_, &Address::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SignMessage_descriptor_, &SignMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MessageSignature_descriptor_, &MessageSignature::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    VerifyMessage_descriptor_, &VerifyMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SignTx_descriptor_, &SignTx::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TxRequest_descriptor_, &TxRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TxRequest_TxRequestDetailsType_descriptor_, &TxRequest_TxRequestDetailsType::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TxRequest_TxRequestSerializedType_descriptor_, &TxRequest_TxRequestSerializedType::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TxAck_descriptor_, &TxAck::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TxAck_TransactionType_descriptor_, &TxAck_TransactionType::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TxAck_TransactionType_TxInputType_descriptor_, &TxAck_TransactionType_TxInputType::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TxAck_TransactionType_TxOutputBinType_descriptor_, &TxAck_TransactionType_TxOutputBinType::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TxAck_TransactionType_TxOutputType_descriptor_, &TxAck_TransactionType_TxOutputType::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_messages_2dbitcoin_2eproto() {
  delete MultisigRedeemScriptType::default_instance_;
  delete MultisigRedeemScriptType_reflection_;
  delete MultisigRedeemScriptType_HDNodePathType::default_instance_;
  delete MultisigRedeemScriptType_HDNodePathType_reflection_;
  delete GetPublicKey::default_instance_;
  delete GetPublicKey_reflection_;
  delete GetPublicKey::_default_coin_name_;
  delete PublicKey::default_instance_;
  delete PublicKey_reflection_;
  delete GetAddress::default_instance_;
  delete GetAddress_reflection_;
  delete GetAddress::_default_coin_name_;
  delete Address::default_instance_;
  delete Address_reflection_;
  delete SignMessage::default_instance_;
  delete SignMessage_reflection_;
  delete SignMessage::_default_coin_name_;
  delete MessageSignature::default_instance_;
  delete MessageSignature_reflection_;
  delete VerifyMessage::default_instance_;
  delete VerifyMessage_reflection_;
  delete VerifyMessage::_default_coin_name_;
  delete SignTx::default_instance_;
  delete SignTx_reflection_;
  delete SignTx::_default_coin_name_;
  delete TxRequest::default_instance_;
  delete TxRequest_reflection_;
  delete TxRequest_TxRequestDetailsType::default_instance_;
  delete TxRequest_TxRequestDetailsType_reflection_;
  delete TxRequest_TxRequestSerializedType::default_instance_;
  delete TxRequest_TxRequestSerializedType_reflection_;
  delete TxAck::default_instance_;
  delete TxAck_reflection_;
  delete TxAck_TransactionType::default_instance_;
  delete TxAck_TransactionType_reflection_;
  delete TxAck_TransactionType_TxInputType::default_instance_;
  delete TxAck_TransactionType_TxInputType_reflection_;
  delete TxAck_TransactionType_TxOutputBinType::default_instance_;
  delete TxAck_TransactionType_TxOutputBinType_reflection_;
  delete TxAck_TransactionType_TxOutputType::default_instance_;
  delete TxAck_TransactionType_TxOutputType_reflection_;
}

void protobuf_AddDesc_messages_2dbitcoin_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::protobuf_AddDesc_messages_2dcommon_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\026messages-bitcoin.proto\032\025messages-commo"
    "n.proto\"\264\001\n\030MultisigRedeemScriptType\0229\n\007"
    "pubkeys\030\001 \003(\0132(.MultisigRedeemScriptType"
    ".HDNodePathType\022\022\n\nsignatures\030\002 \003(\014\022\t\n\001m"
    "\030\003 \001(\r\032>\n\016HDNodePathType\022\031\n\004node\030\001 \002(\0132\013"
    ".HDNodeType\022\021\n\taddress_n\030\002 \003(\r\"m\n\014GetPub"
    "licKey\022\021\n\taddress_n\030\001 \003(\r\022\030\n\020ecdsa_curve"
    "_name\030\002 \001(\t\022\024\n\014show_display\030\003 \001(\010\022\032\n\tcoi"
    "n_name\030\004 \001(\t:\007Bitcoin\"4\n\tPublicKey\022\031\n\004no"
    "de\030\001 \002(\0132\013.HDNodeType\022\014\n\004xpub\030\002 \001(\t\"\263\001\n\n"
    "GetAddress\022\021\n\taddress_n\030\001 \003(\r\022\032\n\tcoin_na"
    "me\030\002 \001(\t:\007Bitcoin\022\024\n\014show_display\030\003 \001(\010\022"
    "+\n\010multisig\030\004 \001(\0132\031.MultisigRedeemScript"
    "Type\0223\n\013script_type\030\005 \001(\0162\020.InputScriptT"
    "ype:\014SPENDADDRESS\"\032\n\007Address\022\017\n\007address\030"
    "\001 \002(\t\"\202\001\n\013SignMessage\022\021\n\taddress_n\030\001 \003(\r"
    "\022\017\n\007message\030\002 \002(\014\022\032\n\tcoin_name\030\003 \001(\t:\007Bi"
    "tcoin\0223\n\013script_type\030\004 \001(\0162\020.InputScript"
    "Type:\014SPENDADDRESS\"6\n\020MessageSignature\022\017"
    "\n\007address\030\001 \001(\t\022\021\n\tsignature\030\002 \001(\014\"`\n\rVe"
    "rifyMessage\022\017\n\007address\030\001 \001(\t\022\021\n\tsignatur"
    "e\030\002 \001(\014\022\017\n\007message\030\003 \001(\014\022\032\n\tcoin_name\030\004 "
    "\001(\t:\007Bitcoin\"\241\001\n\006SignTx\022\025\n\routputs_count"
    "\030\001 \002(\r\022\024\n\014inputs_count\030\002 \002(\r\022\032\n\tcoin_nam"
    "e\030\003 \001(\t:\007Bitcoin\022\022\n\007version\030\004 \001(\r:\0011\022\024\n\t"
    "lock_time\030\005 \001(\r:\0010\022\016\n\006expiry\030\006 \001(\r\022\024\n\014ov"
    "erwintered\030\007 \001(\010\"\313\003\n\tTxRequest\022,\n\014reques"
    "t_type\030\001 \001(\0162\026.TxRequest.RequestType\0220\n\007"
    "details\030\002 \001(\0132\037.TxRequest.TxRequestDetai"
    "lsType\0226\n\nserialized\030\003 \001(\0132\".TxRequest.T"
    "xRequestSerializedType\032q\n\024TxRequestDetai"
    "lsType\022\025\n\rrequest_index\030\001 \001(\r\022\017\n\007tx_hash"
    "\030\002 \001(\014\022\026\n\016extra_data_len\030\003 \001(\r\022\031\n\021extra_"
    "data_offset\030\004 \001(\r\032\\\n\027TxRequestSerialized"
    "Type\022\027\n\017signature_index\030\001 \001(\r\022\021\n\tsignatu"
    "re\030\002 \001(\014\022\025\n\rserialized_tx\030\003 \001(\014\"U\n\013Reque"
    "stType\022\013\n\007TXINPUT\020\000\022\014\n\010TXOUTPUT\020\001\022\n\n\006TXM"
    "ETA\020\002\022\016\n\nTXFINISHED\020\003\022\017\n\013TXEXTRADATA\020\004\"\370"
    "\t\n\005TxAck\022\"\n\002tx\030\001 \001(\0132\026.TxAck.Transaction"
    "Type\032\312\t\n\017TransactionType\022\017\n\007version\030\001 \001("
    "\r\0222\n\006inputs\030\002 \003(\0132\".TxAck.TransactionTyp"
    "e.TxInputType\022;\n\013bin_outputs\030\003 \003(\0132&.TxA"
    "ck.TransactionType.TxOutputBinType\022\021\n\tlo"
    "ck_time\030\004 \001(\r\0224\n\007outputs\030\005 \003(\0132#.TxAck.T"
    "ransactionType.TxOutputType\022\022\n\ninputs_cn"
    "t\030\006 \001(\r\022\023\n\013outputs_cnt\030\007 \001(\r\022\022\n\nextra_da"
    "ta\030\010 \001(\014\022\026\n\016extra_data_len\030\t \001(\r\022\016\n\006expi"
    "ry\030\n \001(\r\022\024\n\014overwintered\030\013 \001(\010\032\341\002\n\013TxInp"
    "utType\022\021\n\taddress_n\030\001 \003(\r\022\021\n\tprev_hash\030\002"
    " \002(\014\022\022\n\nprev_index\030\003 \002(\r\022\022\n\nscript_sig\030\004"
    " \001(\014\022\034\n\010sequence\030\005 \001(\r:\n4294967295\0223\n\013sc"
    "ript_type\030\006 \001(\0162\020.InputScriptType:\014SPEND"
    "ADDRESS\022+\n\010multisig\030\007 \001(\0132\031.MultisigRede"
    "emScriptType\022\016\n\006amount\030\010 \001(\004\022\023\n\013decred_t"
    "ree\030\t \001(\r\022\035\n\025decred_script_version\030\n \001(\r"
    "\022\036\n\026prev_block_hash_bip115\030\013 \001(\014\022 \n\030prev"
    "_block_height_bip115\030\014 \001(\r\032W\n\017TxOutputBi"
    "nType\022\016\n\006amount\030\001 \002(\004\022\025\n\rscript_pubkey\030\002"
    " \002(\014\022\035\n\025decred_script_version\030\003 \001(\r\032\263\003\n\014"
    "TxOutputType\022\017\n\007address\030\001 \001(\t\022\021\n\taddress"
    "_n\030\002 \003(\r\022\016\n\006amount\030\003 \002(\004\022I\n\013script_type\030"
    "\004 \002(\01624.TxAck.TransactionType.TxOutputTy"
    "pe.OutputScriptType\022+\n\010multisig\030\005 \001(\0132\031."
    "MultisigRedeemScriptType\022\026\n\016op_return_da"
    "ta\030\006 \001(\014\022\035\n\025decred_script_version\030\007 \001(\r\022"
    "\031\n\021block_hash_bip115\030\010 \001(\014\022\033\n\023block_heig"
    "ht_bip115\030\t \001(\r\"\207\001\n\020OutputScriptType\022\020\n\014"
    "PAYTOADDRESS\020\000\022\023\n\017PAYTOSCRIPTHASH\020\001\022\021\n\rP"
    "AYTOMULTISIG\020\002\022\021\n\rPAYTOOPRETURN\020\003\022\020\n\014PAY"
    "TOWITNESS\020\004\022\024\n\020PAYTOP2SHWITNESS\020\005*l\n\017Inp"
    "utScriptType\022\020\n\014SPENDADDRESS\020\000\022\021\n\rSPENDM"
    "ULTISIG\020\001\022\014\n\010EXTERNAL\020\002\022\020\n\014SPENDWITNESS\020"
    "\003\022\024\n\020SPENDP2SHWITNESS\020\004B;\n#com.satoshila"
    "bs.trezor.lib.protobufB\024TrezorMessageBit"
    "coin", 2964);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "messages-bitcoin.proto", &protobuf_RegisterTypes);
  MultisigRedeemScriptType::default_instance_ = new MultisigRedeemScriptType();
  MultisigRedeemScriptType_HDNodePathType::default_instance_ = new MultisigRedeemScriptType_HDNodePathType();
  GetPublicKey::_default_coin_name_ =
      new ::std::string("Bitcoin", 7);
  GetPublicKey::default_instance_ = new GetPublicKey();
  PublicKey::default_instance_ = new PublicKey();
  GetAddress::_default_coin_name_ =
      new ::std::string("Bitcoin", 7);
  GetAddress::default_instance_ = new GetAddress();
  Address::default_instance_ = new Address();
  SignMessage::_default_coin_name_ =
      new ::std::string("Bitcoin", 7);
  SignMessage::default_instance_ = new SignMessage();
  MessageSignature::default_instance_ = new MessageSignature();
  VerifyMessage::_default_coin_name_ =
      new ::std::string("Bitcoin", 7);
  VerifyMessage::default_instance_ = new VerifyMessage();
  SignTx::_default_coin_name_ =
      new ::std::string("Bitcoin", 7);
  SignTx::default_instance_ = new SignTx();
  TxRequest::default_instance_ = new TxRequest();
  TxRequest_TxRequestDetailsType::default_instance_ = new TxRequest_TxRequestDetailsType();
  TxRequest_TxRequestSerializedType::default_instance_ = new TxRequest_TxRequestSerializedType();
  TxAck::default_instance_ = new TxAck();
  TxAck_TransactionType::default_instance_ = new TxAck_TransactionType();
  TxAck_TransactionType_TxInputType::default_instance_ = new TxAck_TransactionType_TxInputType();
  TxAck_TransactionType_TxOutputBinType::default_instance_ = new TxAck_TransactionType_TxOutputBinType();
  TxAck_TransactionType_TxOutputType::default_instance_ = new TxAck_TransactionType_TxOutputType();
  MultisigRedeemScriptType::default_instance_->InitAsDefaultInstance();
  MultisigRedeemScriptType_HDNodePathType::default_instance_->InitAsDefaultInstance();
  GetPublicKey::default_instance_->InitAsDefaultInstance();
  PublicKey::default_instance_->InitAsDefaultInstance();
  GetAddress::default_instance_->InitAsDefaultInstance();
  Address::default_instance_->InitAsDefaultInstance();
  SignMessage::default_instance_->InitAsDefaultInstance();
  MessageSignature::default_instance_->InitAsDefaultInstance();
  VerifyMessage::default_instance_->InitAsDefaultInstance();
  SignTx::default_instance_->InitAsDefaultInstance();
  TxRequest::default_instance_->InitAsDefaultInstance();
  TxRequest_TxRequestDetailsType::default_instance_->InitAsDefaultInstance();
  TxRequest_TxRequestSerializedType::default_instance_->InitAsDefaultInstance();
  TxAck::default_instance_->InitAsDefaultInstance();
  TxAck_TransactionType::default_instance_->InitAsDefaultInstance();
  TxAck_TransactionType_TxInputType::default_instance_->InitAsDefaultInstance();
  TxAck_TransactionType_TxOutputBinType::default_instance_->InitAsDefaultInstance();
  TxAck_TransactionType_TxOutputType::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_messages_2dbitcoin_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_messages_2dbitcoin_2eproto {
  StaticDescriptorInitializer_messages_2dbitcoin_2eproto() {
    protobuf_AddDesc_messages_2dbitcoin_2eproto();
  }
} static_descriptor_initializer_messages_2dbitcoin_2eproto_;
const ::google::protobuf::EnumDescriptor* InputScriptType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return InputScriptType_descriptor_;
}
bool InputScriptType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int MultisigRedeemScriptType_HDNodePathType::kNodeFieldNumber;
const int MultisigRedeemScriptType_HDNodePathType::kAddressNFieldNumber;
#endif  // !_MSC_VER

MultisigRedeemScriptType_HDNodePathType::MultisigRedeemScriptType_HDNodePathType()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:MultisigRedeemScriptType.HDNodePathType)
}

void MultisigRedeemScriptType_HDNodePathType::InitAsDefaultInstance() {
  node_ = const_cast< ::HDNodeType*>(&::HDNodeType::default_instance());
}

MultisigRedeemScriptType_HDNodePathType::MultisigRedeemScriptType_HDNodePathType(const MultisigRedeemScriptType_HDNodePathType& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:MultisigRedeemScriptType.HDNodePathType)
}

void MultisigRedeemScriptType_HDNodePathType::SharedCtor() {
  _cached_size_ = 0;
  node_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MultisigRedeemScriptType_HDNodePathType::~MultisigRedeemScriptType_HDNodePathType() {
  // @@protoc_insertion_point(destructor:MultisigRedeemScriptType.HDNodePathType)
  SharedDtor();
}

void MultisigRedeemScriptType_HDNodePathType::SharedDtor() {
  if (this != default_instance_) {
    delete node_;
  }
}

void MultisigRedeemScriptType_HDNodePathType::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MultisigRedeemScriptType_HDNodePathType::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MultisigRedeemScriptType_HDNodePathType_descriptor_;
}

const MultisigRedeemScriptType_HDNodePathType& MultisigRedeemScriptType_HDNodePathType::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2dbitcoin_2eproto();
  return *default_instance_;
}

MultisigRedeemScriptType_HDNodePathType* MultisigRedeemScriptType_HDNodePathType::default_instance_ = NULL;

MultisigRedeemScriptType_HDNodePathType* MultisigRedeemScriptType_HDNodePathType::New() const {
  return new MultisigRedeemScriptType_HDNodePathType;
}

void MultisigRedeemScriptType_HDNodePathType::Clear() {
  if (has_node()) {
    if (node_ != NULL) node_->::HDNodeType::Clear();
  }
  address_n_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MultisigRedeemScriptType_HDNodePathType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:MultisigRedeemScriptType.HDNodePathType)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .HDNodeType node = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_node()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_address_n;
        break;
      }

      // repeated uint32 address_n = 2;
      case 2: {
        if (tag == 16) {
         parse_address_n:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 16, input, this->mutable_address_n())));
        } else if (tag == 18) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_address_n())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_address_n;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:MultisigRedeemScriptType.HDNodePathType)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:MultisigRedeemScriptType.HDNodePathType)
  return false;
#undef DO_
}

void MultisigRedeemScriptType_HDNodePathType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:MultisigRedeemScriptType.HDNodePathType)
  // required .HDNodeType node = 1;
  if (has_node()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->node(), output);
  }

  // repeated uint32 address_n = 2;
  for (int i = 0; i < this->address_n_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      2, this->address_n(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:MultisigRedeemScriptType.HDNodePathType)
}

::google::protobuf::uint8* MultisigRedeemScriptType_HDNodePathType::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:MultisigRedeemScriptType.HDNodePathType)
  // required .HDNodeType node = 1;
  if (has_node()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->node(), target);
  }

  // repeated uint32 address_n = 2;
  for (int i = 0; i < this->address_n_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(2, this->address_n(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MultisigRedeemScriptType.HDNodePathType)
  return target;
}

int MultisigRedeemScriptType_HDNodePathType::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .HDNodeType node = 1;
    if (has_node()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->node());
    }

  }
  // repeated uint32 address_n = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->address_n_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->address_n(i));
    }
    total_size += 1 * this->address_n_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MultisigRedeemScriptType_HDNodePathType::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MultisigRedeemScriptType_HDNodePathType* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MultisigRedeemScriptType_HDNodePathType*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MultisigRedeemScriptType_HDNodePathType::MergeFrom(const MultisigRedeemScriptType_HDNodePathType& from) {
  GOOGLE_CHECK_NE(&from, this);
  address_n_.MergeFrom(from.address_n_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_node()) {
      mutable_node()->::HDNodeType::MergeFrom(from.node());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MultisigRedeemScriptType_HDNodePathType::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MultisigRedeemScriptType_HDNodePathType::CopyFrom(const MultisigRedeemScriptType_HDNodePathType& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MultisigRedeemScriptType_HDNodePathType::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_node()) {
    if (!this->node().IsInitialized()) return false;
  }
  return true;
}

void MultisigRedeemScriptType_HDNodePathType::Swap(MultisigRedeemScriptType_HDNodePathType* other) {
  if (other != this) {
    std::swap(node_, other->node_);
    address_n_.Swap(&other->address_n_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MultisigRedeemScriptType_HDNodePathType::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MultisigRedeemScriptType_HDNodePathType_descriptor_;
  metadata.reflection = MultisigRedeemScriptType_HDNodePathType_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int MultisigRedeemScriptType::kPubkeysFieldNumber;
const int MultisigRedeemScriptType::kSignaturesFieldNumber;
const int MultisigRedeemScriptType::kMFieldNumber;
#endif  // !_MSC_VER

MultisigRedeemScriptType::MultisigRedeemScriptType()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:MultisigRedeemScriptType)
}

void MultisigRedeemScriptType::InitAsDefaultInstance() {
}

MultisigRedeemScriptType::MultisigRedeemScriptType(const MultisigRedeemScriptType& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:MultisigRedeemScriptType)
}

void MultisigRedeemScriptType::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  m_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MultisigRedeemScriptType::~MultisigRedeemScriptType() {
  // @@protoc_insertion_point(destructor:MultisigRedeemScriptType)
  SharedDtor();
}

void MultisigRedeemScriptType::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MultisigRedeemScriptType::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MultisigRedeemScriptType::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MultisigRedeemScriptType_descriptor_;
}

const MultisigRedeemScriptType& MultisigRedeemScriptType::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2dbitcoin_2eproto();
  return *default_instance_;
}

MultisigRedeemScriptType* MultisigRedeemScriptType::default_instance_ = NULL;

MultisigRedeemScriptType* MultisigRedeemScriptType::New() const {
  return new MultisigRedeemScriptType;
}

void MultisigRedeemScriptType::Clear() {
  m_ = 0u;
  pubkeys_.Clear();
  signatures_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MultisigRedeemScriptType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:MultisigRedeemScriptType)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .MultisigRedeemScriptType.HDNodePathType pubkeys = 1;
      case 1: {
        if (tag == 10) {
         parse_pubkeys:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_pubkeys()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_pubkeys;
        if (input->ExpectTag(18)) goto parse_signatures;
        break;
      }

      // repeated bytes signatures = 2;
      case 2: {
        if (tag == 18) {
         parse_signatures:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_signatures()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_signatures;
        if (input->ExpectTag(24)) goto parse_m;
        break;
      }

      // optional uint32 m = 3;
      case 3: {
        if (tag == 24) {
         parse_m:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &m_)));
          set_has_m();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:MultisigRedeemScriptType)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:MultisigRedeemScriptType)
  return false;
#undef DO_
}

void MultisigRedeemScriptType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:MultisigRedeemScriptType)
  // repeated .MultisigRedeemScriptType.HDNodePathType pubkeys = 1;
  for (int i = 0; i < this->pubkeys_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->pubkeys(i), output);
  }

  // repeated bytes signatures = 2;
  for (int i = 0; i < this->signatures_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->signatures(i), output);
  }

  // optional uint32 m = 3;
  if (has_m()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->m(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:MultisigRedeemScriptType)
}

::google::protobuf::uint8* MultisigRedeemScriptType::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:MultisigRedeemScriptType)
  // repeated .MultisigRedeemScriptType.HDNodePathType pubkeys = 1;
  for (int i = 0; i < this->pubkeys_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->pubkeys(i), target);
  }

  // repeated bytes signatures = 2;
  for (int i = 0; i < this->signatures_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBytesToArray(2, this->signatures(i), target);
  }

  // optional uint32 m = 3;
  if (has_m()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->m(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MultisigRedeemScriptType)
  return target;
}

int MultisigRedeemScriptType::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    // optional uint32 m = 3;
    if (has_m()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->m());
    }

  }
  // repeated .MultisigRedeemScriptType.HDNodePathType pubkeys = 1;
  total_size += 1 * this->pubkeys_size();
  for (int i = 0; i < this->pubkeys_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->pubkeys(i));
  }

  // repeated bytes signatures = 2;
  total_size += 1 * this->signatures_size();
  for (int i = 0; i < this->signatures_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->signatures(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MultisigRedeemScriptType::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MultisigRedeemScriptType* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MultisigRedeemScriptType*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MultisigRedeemScriptType::MergeFrom(const MultisigRedeemScriptType& from) {
  GOOGLE_CHECK_NE(&from, this);
  pubkeys_.MergeFrom(from.pubkeys_);
  signatures_.MergeFrom(from.signatures_);
  if (from._has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    if (from.has_m()) {
      set_m(from.m());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MultisigRedeemScriptType::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MultisigRedeemScriptType::CopyFrom(const MultisigRedeemScriptType& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MultisigRedeemScriptType::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->pubkeys())) return false;
  return true;
}

void MultisigRedeemScriptType::Swap(MultisigRedeemScriptType* other) {
  if (other != this) {
    pubkeys_.Swap(&other->pubkeys_);
    signatures_.Swap(&other->signatures_);
    std::swap(m_, other->m_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MultisigRedeemScriptType::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MultisigRedeemScriptType_descriptor_;
  metadata.reflection = MultisigRedeemScriptType_reflection_;
  return metadata;
}


// ===================================================================

::std::string* GetPublicKey::_default_coin_name_ = NULL;
#ifndef _MSC_VER
const int GetPublicKey::kAddressNFieldNumber;
const int GetPublicKey::kEcdsaCurveNameFieldNumber;
const int GetPublicKey::kShowDisplayFieldNumber;
const int GetPublicKey::kCoinNameFieldNumber;
#endif  // !_MSC_VER

GetPublicKey::GetPublicKey()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:GetPublicKey)
}

void GetPublicKey::InitAsDefaultInstance() {
}

GetPublicKey::GetPublicKey(const GetPublicKey& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:GetPublicKey)
}

void GetPublicKey::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  ecdsa_curve_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  show_display_ = false;
  coin_name_ = const_cast< ::std::string*>(_default_coin_name_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetPublicKey::~GetPublicKey() {
  // @@protoc_insertion_point(destructor:GetPublicKey)
  SharedDtor();
}

void GetPublicKey::SharedDtor() {
  if (ecdsa_curve_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ecdsa_curve_name_;
  }
  if (coin_name_ != _default_coin_name_) {
    delete coin_name_;
  }
  if (this != default_instance_) {
  }
}

void GetPublicKey::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetPublicKey::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GetPublicKey_descriptor_;
}

const GetPublicKey& GetPublicKey::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2dbitcoin_2eproto();
  return *default_instance_;
}

GetPublicKey* GetPublicKey::default_instance_ = NULL;

GetPublicKey* GetPublicKey::New() const {
  return new GetPublicKey;
}

void GetPublicKey::Clear() {
  if (_has_bits_[0 / 32] & 14) {
    if (has_ecdsa_curve_name()) {
      if (ecdsa_curve_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        ecdsa_curve_name_->clear();
      }
    }
    show_display_ = false;
    if (has_coin_name()) {
      if (coin_name_ != _default_coin_name_) {
        coin_name_->assign(*_default_coin_name_);
      }
    }
  }
  address_n_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GetPublicKey::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:GetPublicKey)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 address_n = 1;
      case 1: {
        if (tag == 8) {
         parse_address_n:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8, input, this->mutable_address_n())));
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_address_n())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(8)) goto parse_address_n;
        if (input->ExpectTag(18)) goto parse_ecdsa_curve_name;
        break;
      }

      // optional string ecdsa_curve_name = 2;
      case 2: {
        if (tag == 18) {
         parse_ecdsa_curve_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ecdsa_curve_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->ecdsa_curve_name().data(), this->ecdsa_curve_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "ecdsa_curve_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_show_display;
        break;
      }

      // optional bool show_display = 3;
      case 3: {
        if (tag == 24) {
         parse_show_display:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &show_display_)));
          set_has_show_display();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_coin_name;
        break;
      }

      // optional string coin_name = 4 [default = "Bitcoin"];
      case 4: {
        if (tag == 34) {
         parse_coin_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_coin_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->coin_name().data(), this->coin_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "coin_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:GetPublicKey)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:GetPublicKey)
  return false;
#undef DO_
}

void GetPublicKey::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:GetPublicKey)
  // repeated uint32 address_n = 1;
  for (int i = 0; i < this->address_n_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->address_n(i), output);
  }

  // optional string ecdsa_curve_name = 2;
  if (has_ecdsa_curve_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->ecdsa_curve_name().data(), this->ecdsa_curve_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "ecdsa_curve_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->ecdsa_curve_name(), output);
  }

  // optional bool show_display = 3;
  if (has_show_display()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->show_display(), output);
  }

  // optional string coin_name = 4 [default = "Bitcoin"];
  if (has_coin_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->coin_name().data(), this->coin_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "coin_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->coin_name(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:GetPublicKey)
}

::google::protobuf::uint8* GetPublicKey::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:GetPublicKey)
  // repeated uint32 address_n = 1;
  for (int i = 0; i < this->address_n_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(1, this->address_n(i), target);
  }

  // optional string ecdsa_curve_name = 2;
  if (has_ecdsa_curve_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->ecdsa_curve_name().data(), this->ecdsa_curve_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "ecdsa_curve_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->ecdsa_curve_name(), target);
  }

  // optional bool show_display = 3;
  if (has_show_display()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->show_display(), target);
  }

  // optional string coin_name = 4 [default = "Bitcoin"];
  if (has_coin_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->coin_name().data(), this->coin_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "coin_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->coin_name(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:GetPublicKey)
  return target;
}

int GetPublicKey::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional string ecdsa_curve_name = 2;
    if (has_ecdsa_curve_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ecdsa_curve_name());
    }

    // optional bool show_display = 3;
    if (has_show_display()) {
      total_size += 1 + 1;
    }

    // optional string coin_name = 4 [default = "Bitcoin"];
    if (has_coin_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->coin_name());
    }

  }
  // repeated uint32 address_n = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->address_n_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->address_n(i));
    }
    total_size += 1 * this->address_n_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetPublicKey::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GetPublicKey* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GetPublicKey*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GetPublicKey::MergeFrom(const GetPublicKey& from) {
  GOOGLE_CHECK_NE(&from, this);
  address_n_.MergeFrom(from.address_n_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_ecdsa_curve_name()) {
      set_ecdsa_curve_name(from.ecdsa_curve_name());
    }
    if (from.has_show_display()) {
      set_show_display(from.show_display());
    }
    if (from.has_coin_name()) {
      set_coin_name(from.coin_name());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GetPublicKey::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetPublicKey::CopyFrom(const GetPublicKey& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetPublicKey::IsInitialized() const {

  return true;
}

void GetPublicKey::Swap(GetPublicKey* other) {
  if (other != this) {
    address_n_.Swap(&other->address_n_);
    std::swap(ecdsa_curve_name_, other->ecdsa_curve_name_);
    std::swap(show_display_, other->show_display_);
    std::swap(coin_name_, other->coin_name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GetPublicKey::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GetPublicKey_descriptor_;
  metadata.reflection = GetPublicKey_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PublicKey::kNodeFieldNumber;
const int PublicKey::kXpubFieldNumber;
#endif  // !_MSC_VER

PublicKey::PublicKey()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:PublicKey)
}

void PublicKey::InitAsDefaultInstance() {
  node_ = const_cast< ::HDNodeType*>(&::HDNodeType::default_instance());
}

PublicKey::PublicKey(const PublicKey& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:PublicKey)
}

void PublicKey::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  node_ = NULL;
  xpub_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PublicKey::~PublicKey() {
  // @@protoc_insertion_point(destructor:PublicKey)
  SharedDtor();
}

void PublicKey::SharedDtor() {
  if (xpub_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete xpub_;
  }
  if (this != default_instance_) {
    delete node_;
  }
}

void PublicKey::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PublicKey::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PublicKey_descriptor_;
}

const PublicKey& PublicKey::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2dbitcoin_2eproto();
  return *default_instance_;
}

PublicKey* PublicKey::default_instance_ = NULL;

PublicKey* PublicKey::New() const {
  return new PublicKey;
}

void PublicKey::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_node()) {
      if (node_ != NULL) node_->::HDNodeType::Clear();
    }
    if (has_xpub()) {
      if (xpub_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        xpub_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PublicKey::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:PublicKey)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .HDNodeType node = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_node()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_xpub;
        break;
      }

      // optional string xpub = 2;
      case 2: {
        if (tag == 18) {
         parse_xpub:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_xpub()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->xpub().data(), this->xpub().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "xpub");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:PublicKey)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:PublicKey)
  return false;
#undef DO_
}

void PublicKey::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:PublicKey)
  // required .HDNodeType node = 1;
  if (has_node()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->node(), output);
  }

  // optional string xpub = 2;
  if (has_xpub()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->xpub().data(), this->xpub().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "xpub");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->xpub(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:PublicKey)
}

::google::protobuf::uint8* PublicKey::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:PublicKey)
  // required .HDNodeType node = 1;
  if (has_node()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->node(), target);
  }

  // optional string xpub = 2;
  if (has_xpub()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->xpub().data(), this->xpub().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "xpub");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->xpub(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PublicKey)
  return target;
}

int PublicKey::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .HDNodeType node = 1;
    if (has_node()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->node());
    }

    // optional string xpub = 2;
    if (has_xpub()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->xpub());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PublicKey::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PublicKey* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PublicKey*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PublicKey::MergeFrom(const PublicKey& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_node()) {
      mutable_node()->::HDNodeType::MergeFrom(from.node());
    }
    if (from.has_xpub()) {
      set_xpub(from.xpub());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PublicKey::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PublicKey::CopyFrom(const PublicKey& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PublicKey::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_node()) {
    if (!this->node().IsInitialized()) return false;
  }
  return true;
}

void PublicKey::Swap(PublicKey* other) {
  if (other != this) {
    std::swap(node_, other->node_);
    std::swap(xpub_, other->xpub_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PublicKey::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PublicKey_descriptor_;
  metadata.reflection = PublicKey_reflection_;
  return metadata;
}


// ===================================================================

::std::string* GetAddress::_default_coin_name_ = NULL;
#ifndef _MSC_VER
const int GetAddress::kAddressNFieldNumber;
const int GetAddress::kCoinNameFieldNumber;
const int GetAddress::kShowDisplayFieldNumber;
const int GetAddress::kMultisigFieldNumber;
const int GetAddress::kScriptTypeFieldNumber;
#endif  // !_MSC_VER

GetAddress::GetAddress()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:GetAddress)
}

void GetAddress::InitAsDefaultInstance() {
  multisig_ = const_cast< ::MultisigRedeemScriptType*>(&::MultisigRedeemScriptType::default_instance());
}

GetAddress::GetAddress(const GetAddress& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:GetAddress)
}

void GetAddress::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  coin_name_ = const_cast< ::std::string*>(_default_coin_name_);
  show_display_ = false;
  multisig_ = NULL;
  script_type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetAddress::~GetAddress() {
  // @@protoc_insertion_point(destructor:GetAddress)
  SharedDtor();
}

void GetAddress::SharedDtor() {
  if (coin_name_ != _default_coin_name_) {
    delete coin_name_;
  }
  if (this != default_instance_) {
    delete multisig_;
  }
}

void GetAddress::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetAddress::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GetAddress_descriptor_;
}

const GetAddress& GetAddress::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2dbitcoin_2eproto();
  return *default_instance_;
}

GetAddress* GetAddress::default_instance_ = NULL;

GetAddress* GetAddress::New() const {
  return new GetAddress;
}

void GetAddress::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<GetAddress*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 30) {
    ZR_(show_display_, script_type_);
    if (has_coin_name()) {
      if (coin_name_ != _default_coin_name_) {
        coin_name_->assign(*_default_coin_name_);
      }
    }
    if (has_multisig()) {
      if (multisig_ != NULL) multisig_->::MultisigRedeemScriptType::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  address_n_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GetAddress::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:GetAddress)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 address_n = 1;
      case 1: {
        if (tag == 8) {
         parse_address_n:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8, input, this->mutable_address_n())));
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_address_n())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(8)) goto parse_address_n;
        if (input->ExpectTag(18)) goto parse_coin_name;
        break;
      }

      // optional string coin_name = 2 [default = "Bitcoin"];
      case 2: {
        if (tag == 18) {
         parse_coin_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_coin_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->coin_name().data(), this->coin_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "coin_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_show_display;
        break;
      }

      // optional bool show_display = 3;
      case 3: {
        if (tag == 24) {
         parse_show_display:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &show_display_)));
          set_has_show_display();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_multisig;
        break;
      }

      // optional .MultisigRedeemScriptType multisig = 4;
      case 4: {
        if (tag == 34) {
         parse_multisig:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_multisig()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_script_type;
        break;
      }

      // optional .InputScriptType script_type = 5 [default = SPENDADDRESS];
      case 5: {
        if (tag == 40) {
         parse_script_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::InputScriptType_IsValid(value)) {
            set_script_type(static_cast< ::InputScriptType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(5, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:GetAddress)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:GetAddress)
  return false;
#undef DO_
}

void GetAddress::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:GetAddress)
  // repeated uint32 address_n = 1;
  for (int i = 0; i < this->address_n_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->address_n(i), output);
  }

  // optional string coin_name = 2 [default = "Bitcoin"];
  if (has_coin_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->coin_name().data(), this->coin_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "coin_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->coin_name(), output);
  }

  // optional bool show_display = 3;
  if (has_show_display()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->show_display(), output);
  }

  // optional .MultisigRedeemScriptType multisig = 4;
  if (has_multisig()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->multisig(), output);
  }

  // optional .InputScriptType script_type = 5 [default = SPENDADDRESS];
  if (has_script_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->script_type(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:GetAddress)
}

::google::protobuf::uint8* GetAddress::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:GetAddress)
  // repeated uint32 address_n = 1;
  for (int i = 0; i < this->address_n_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(1, this->address_n(i), target);
  }

  // optional string coin_name = 2 [default = "Bitcoin"];
  if (has_coin_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->coin_name().data(), this->coin_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "coin_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->coin_name(), target);
  }

  // optional bool show_display = 3;
  if (has_show_display()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->show_display(), target);
  }

  // optional .MultisigRedeemScriptType multisig = 4;
  if (has_multisig()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->multisig(), target);
  }

  // optional .InputScriptType script_type = 5 [default = SPENDADDRESS];
  if (has_script_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      5, this->script_type(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:GetAddress)
  return target;
}

int GetAddress::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional string coin_name = 2 [default = "Bitcoin"];
    if (has_coin_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->coin_name());
    }

    // optional bool show_display = 3;
    if (has_show_display()) {
      total_size += 1 + 1;
    }

    // optional .MultisigRedeemScriptType multisig = 4;
    if (has_multisig()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->multisig());
    }

    // optional .InputScriptType script_type = 5 [default = SPENDADDRESS];
    if (has_script_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->script_type());
    }

  }
  // repeated uint32 address_n = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->address_n_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->address_n(i));
    }
    total_size += 1 * this->address_n_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetAddress::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GetAddress* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GetAddress*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GetAddress::MergeFrom(const GetAddress& from) {
  GOOGLE_CHECK_NE(&from, this);
  address_n_.MergeFrom(from.address_n_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_coin_name()) {
      set_coin_name(from.coin_name());
    }
    if (from.has_show_display()) {
      set_show_display(from.show_display());
    }
    if (from.has_multisig()) {
      mutable_multisig()->::MultisigRedeemScriptType::MergeFrom(from.multisig());
    }
    if (from.has_script_type()) {
      set_script_type(from.script_type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GetAddress::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetAddress::CopyFrom(const GetAddress& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetAddress::IsInitialized() const {

  if (has_multisig()) {
    if (!this->multisig().IsInitialized()) return false;
  }
  return true;
}

void GetAddress::Swap(GetAddress* other) {
  if (other != this) {
    address_n_.Swap(&other->address_n_);
    std::swap(coin_name_, other->coin_name_);
    std::swap(show_display_, other->show_display_);
    std::swap(multisig_, other->multisig_);
    std::swap(script_type_, other->script_type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GetAddress::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GetAddress_descriptor_;
  metadata.reflection = GetAddress_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Address::kAddressFieldNumber;
#endif  // !_MSC_VER

Address::Address()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Address)
}

void Address::InitAsDefaultInstance() {
}

Address::Address(const Address& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Address)
}

void Address::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Address::~Address() {
  // @@protoc_insertion_point(destructor:Address)
  SharedDtor();
}

void Address::SharedDtor() {
  if (address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete address_;
  }
  if (this != default_instance_) {
  }
}

void Address::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Address::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Address_descriptor_;
}

const Address& Address::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2dbitcoin_2eproto();
  return *default_instance_;
}

Address* Address::default_instance_ = NULL;

Address* Address::New() const {
  return new Address;
}

void Address::Clear() {
  if (has_address()) {
    if (address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      address_->clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Address::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Address)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string address = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_address()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->address().data(), this->address().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "address");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Address)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Address)
  return false;
#undef DO_
}

void Address::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Address)
  // required string address = 1;
  if (has_address()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->address().data(), this->address().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "address");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->address(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Address)
}

::google::protobuf::uint8* Address::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Address)
  // required string address = 1;
  if (has_address()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->address().data(), this->address().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "address");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->address(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Address)
  return target;
}

int Address::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string address = 1;
    if (has_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->address());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Address::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Address* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Address*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Address::MergeFrom(const Address& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_address()) {
      set_address(from.address());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Address::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Address::CopyFrom(const Address& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Address::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Address::Swap(Address* other) {
  if (other != this) {
    std::swap(address_, other->address_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Address::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Address_descriptor_;
  metadata.reflection = Address_reflection_;
  return metadata;
}


// ===================================================================

::std::string* SignMessage::_default_coin_name_ = NULL;
#ifndef _MSC_VER
const int SignMessage::kAddressNFieldNumber;
const int SignMessage::kMessageFieldNumber;
const int SignMessage::kCoinNameFieldNumber;
const int SignMessage::kScriptTypeFieldNumber;
#endif  // !_MSC_VER

SignMessage::SignMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SignMessage)
}

void SignMessage::InitAsDefaultInstance() {
}

SignMessage::SignMessage(const SignMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:SignMessage)
}

void SignMessage::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  coin_name_ = const_cast< ::std::string*>(_default_coin_name_);
  script_type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SignMessage::~SignMessage() {
  // @@protoc_insertion_point(destructor:SignMessage)
  SharedDtor();
}

void SignMessage::SharedDtor() {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_;
  }
  if (coin_name_ != _default_coin_name_) {
    delete coin_name_;
  }
  if (this != default_instance_) {
  }
}

void SignMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SignMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SignMessage_descriptor_;
}

const SignMessage& SignMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2dbitcoin_2eproto();
  return *default_instance_;
}

SignMessage* SignMessage::default_instance_ = NULL;

SignMessage* SignMessage::New() const {
  return new SignMessage;
}

void SignMessage::Clear() {
  if (_has_bits_[0 / 32] & 14) {
    if (has_message()) {
      if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        message_->clear();
      }
    }
    if (has_coin_name()) {
      if (coin_name_ != _default_coin_name_) {
        coin_name_->assign(*_default_coin_name_);
      }
    }
    script_type_ = 0;
  }
  address_n_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SignMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:SignMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 address_n = 1;
      case 1: {
        if (tag == 8) {
         parse_address_n:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8, input, this->mutable_address_n())));
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_address_n())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(8)) goto parse_address_n;
        if (input->ExpectTag(18)) goto parse_message;
        break;
      }

      // required bytes message = 2;
      case 2: {
        if (tag == 18) {
         parse_message:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_message()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_coin_name;
        break;
      }

      // optional string coin_name = 3 [default = "Bitcoin"];
      case 3: {
        if (tag == 26) {
         parse_coin_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_coin_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->coin_name().data(), this->coin_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "coin_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_script_type;
        break;
      }

      // optional .InputScriptType script_type = 4 [default = SPENDADDRESS];
      case 4: {
        if (tag == 32) {
         parse_script_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::InputScriptType_IsValid(value)) {
            set_script_type(static_cast< ::InputScriptType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(4, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:SignMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:SignMessage)
  return false;
#undef DO_
}

void SignMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:SignMessage)
  // repeated uint32 address_n = 1;
  for (int i = 0; i < this->address_n_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->address_n(i), output);
  }

  // required bytes message = 2;
  if (has_message()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->message(), output);
  }

  // optional string coin_name = 3 [default = "Bitcoin"];
  if (has_coin_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->coin_name().data(), this->coin_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "coin_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->coin_name(), output);
  }

  // optional .InputScriptType script_type = 4 [default = SPENDADDRESS];
  if (has_script_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->script_type(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:SignMessage)
}

::google::protobuf::uint8* SignMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:SignMessage)
  // repeated uint32 address_n = 1;
  for (int i = 0; i < this->address_n_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(1, this->address_n(i), target);
  }

  // required bytes message = 2;
  if (has_message()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->message(), target);
  }

  // optional string coin_name = 3 [default = "Bitcoin"];
  if (has_coin_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->coin_name().data(), this->coin_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "coin_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->coin_name(), target);
  }

  // optional .InputScriptType script_type = 4 [default = SPENDADDRESS];
  if (has_script_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->script_type(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SignMessage)
  return target;
}

int SignMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // required bytes message = 2;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->message());
    }

    // optional string coin_name = 3 [default = "Bitcoin"];
    if (has_coin_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->coin_name());
    }

    // optional .InputScriptType script_type = 4 [default = SPENDADDRESS];
    if (has_script_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->script_type());
    }

  }
  // repeated uint32 address_n = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->address_n_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->address_n(i));
    }
    total_size += 1 * this->address_n_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SignMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SignMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SignMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SignMessage::MergeFrom(const SignMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  address_n_.MergeFrom(from.address_n_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_message()) {
      set_message(from.message());
    }
    if (from.has_coin_name()) {
      set_coin_name(from.coin_name());
    }
    if (from.has_script_type()) {
      set_script_type(from.script_type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SignMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SignMessage::CopyFrom(const SignMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SignMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;

  return true;
}

void SignMessage::Swap(SignMessage* other) {
  if (other != this) {
    address_n_.Swap(&other->address_n_);
    std::swap(message_, other->message_);
    std::swap(coin_name_, other->coin_name_);
    std::swap(script_type_, other->script_type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SignMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SignMessage_descriptor_;
  metadata.reflection = SignMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MessageSignature::kAddressFieldNumber;
const int MessageSignature::kSignatureFieldNumber;
#endif  // !_MSC_VER

MessageSignature::MessageSignature()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:MessageSignature)
}

void MessageSignature::InitAsDefaultInstance() {
}

MessageSignature::MessageSignature(const MessageSignature& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:MessageSignature)
}

void MessageSignature::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MessageSignature::~MessageSignature() {
  // @@protoc_insertion_point(destructor:MessageSignature)
  SharedDtor();
}

void MessageSignature::SharedDtor() {
  if (address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete address_;
  }
  if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete signature_;
  }
  if (this != default_instance_) {
  }
}

void MessageSignature::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MessageSignature::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MessageSignature_descriptor_;
}

const MessageSignature& MessageSignature::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2dbitcoin_2eproto();
  return *default_instance_;
}

MessageSignature* MessageSignature::default_instance_ = NULL;

MessageSignature* MessageSignature::New() const {
  return new MessageSignature;
}

void MessageSignature::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_address()) {
      if (address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        address_->clear();
      }
    }
    if (has_signature()) {
      if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        signature_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MessageSignature::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:MessageSignature)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string address = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_address()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->address().data(), this->address().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "address");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_signature;
        break;
      }

      // optional bytes signature = 2;
      case 2: {
        if (tag == 18) {
         parse_signature:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_signature()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:MessageSignature)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:MessageSignature)
  return false;
#undef DO_
}

void MessageSignature::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:MessageSignature)
  // optional string address = 1;
  if (has_address()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->address().data(), this->address().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "address");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->address(), output);
  }

  // optional bytes signature = 2;
  if (has_signature()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->signature(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:MessageSignature)
}

::google::protobuf::uint8* MessageSignature::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:MessageSignature)
  // optional string address = 1;
  if (has_address()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->address().data(), this->address().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "address");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->address(), target);
  }

  // optional bytes signature = 2;
  if (has_signature()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->signature(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MessageSignature)
  return target;
}

int MessageSignature::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string address = 1;
    if (has_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->address());
    }

    // optional bytes signature = 2;
    if (has_signature()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->signature());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MessageSignature::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MessageSignature* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MessageSignature*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MessageSignature::MergeFrom(const MessageSignature& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_address()) {
      set_address(from.address());
    }
    if (from.has_signature()) {
      set_signature(from.signature());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MessageSignature::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MessageSignature::CopyFrom(const MessageSignature& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MessageSignature::IsInitialized() const {

  return true;
}

void MessageSignature::Swap(MessageSignature* other) {
  if (other != this) {
    std::swap(address_, other->address_);
    std::swap(signature_, other->signature_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MessageSignature::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MessageSignature_descriptor_;
  metadata.reflection = MessageSignature_reflection_;
  return metadata;
}


// ===================================================================

::std::string* VerifyMessage::_default_coin_name_ = NULL;
#ifndef _MSC_VER
const int VerifyMessage::kAddressFieldNumber;
const int VerifyMessage::kSignatureFieldNumber;
const int VerifyMessage::kMessageFieldNumber;
const int VerifyMessage::kCoinNameFieldNumber;
#endif  // !_MSC_VER

VerifyMessage::VerifyMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:VerifyMessage)
}

void VerifyMessage::InitAsDefaultInstance() {
}

VerifyMessage::VerifyMessage(const VerifyMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:VerifyMessage)
}

void VerifyMessage::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  coin_name_ = const_cast< ::std::string*>(_default_coin_name_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VerifyMessage::~VerifyMessage() {
  // @@protoc_insertion_point(destructor:VerifyMessage)
  SharedDtor();
}

void VerifyMessage::SharedDtor() {
  if (address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete address_;
  }
  if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete signature_;
  }
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_;
  }
  if (coin_name_ != _default_coin_name_) {
    delete coin_name_;
  }
  if (this != default_instance_) {
  }
}

void VerifyMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* VerifyMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VerifyMessage_descriptor_;
}

const VerifyMessage& VerifyMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2dbitcoin_2eproto();
  return *default_instance_;
}

VerifyMessage* VerifyMessage::default_instance_ = NULL;

VerifyMessage* VerifyMessage::New() const {
  return new VerifyMessage;
}

void VerifyMessage::Clear() {
  if (_has_bits_[0 / 32] & 15) {
    if (has_address()) {
      if (address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        address_->clear();
      }
    }
    if (has_signature()) {
      if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        signature_->clear();
      }
    }
    if (has_message()) {
      if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        message_->clear();
      }
    }
    if (has_coin_name()) {
      if (coin_name_ != _default_coin_name_) {
        coin_name_->assign(*_default_coin_name_);
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool VerifyMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:VerifyMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string address = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_address()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->address().data(), this->address().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "address");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_signature;
        break;
      }

      // optional bytes signature = 2;
      case 2: {
        if (tag == 18) {
         parse_signature:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_signature()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_message;
        break;
      }

      // optional bytes message = 3;
      case 3: {
        if (tag == 26) {
         parse_message:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_message()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_coin_name;
        break;
      }

      // optional string coin_name = 4 [default = "Bitcoin"];
      case 4: {
        if (tag == 34) {
         parse_coin_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_coin_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->coin_name().data(), this->coin_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "coin_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:VerifyMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:VerifyMessage)
  return false;
#undef DO_
}

void VerifyMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:VerifyMessage)
  // optional string address = 1;
  if (has_address()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->address().data(), this->address().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "address");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->address(), output);
  }

  // optional bytes signature = 2;
  if (has_signature()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->signature(), output);
  }

  // optional bytes message = 3;
  if (has_message()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->message(), output);
  }

  // optional string coin_name = 4 [default = "Bitcoin"];
  if (has_coin_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->coin_name().data(), this->coin_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "coin_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->coin_name(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:VerifyMessage)
}

::google::protobuf::uint8* VerifyMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:VerifyMessage)
  // optional string address = 1;
  if (has_address()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->address().data(), this->address().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "address");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->address(), target);
  }

  // optional bytes signature = 2;
  if (has_signature()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->signature(), target);
  }

  // optional bytes message = 3;
  if (has_message()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->message(), target);
  }

  // optional string coin_name = 4 [default = "Bitcoin"];
  if (has_coin_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->coin_name().data(), this->coin_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "coin_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->coin_name(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:VerifyMessage)
  return target;
}

int VerifyMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string address = 1;
    if (has_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->address());
    }

    // optional bytes signature = 2;
    if (has_signature()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->signature());
    }

    // optional bytes message = 3;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->message());
    }

    // optional string coin_name = 4 [default = "Bitcoin"];
    if (has_coin_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->coin_name());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VerifyMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const VerifyMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const VerifyMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void VerifyMessage::MergeFrom(const VerifyMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_address()) {
      set_address(from.address());
    }
    if (from.has_signature()) {
      set_signature(from.signature());
    }
    if (from.has_message()) {
      set_message(from.message());
    }
    if (from.has_coin_name()) {
      set_coin_name(from.coin_name());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void VerifyMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VerifyMessage::CopyFrom(const VerifyMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VerifyMessage::IsInitialized() const {

  return true;
}

void VerifyMessage::Swap(VerifyMessage* other) {
  if (other != this) {
    std::swap(address_, other->address_);
    std::swap(signature_, other->signature_);
    std::swap(message_, other->message_);
    std::swap(coin_name_, other->coin_name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata VerifyMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = VerifyMessage_descriptor_;
  metadata.reflection = VerifyMessage_reflection_;
  return metadata;
}


// ===================================================================

::std::string* SignTx::_default_coin_name_ = NULL;
#ifndef _MSC_VER
const int SignTx::kOutputsCountFieldNumber;
const int SignTx::kInputsCountFieldNumber;
const int SignTx::kCoinNameFieldNumber;
const int SignTx::kVersionFieldNumber;
const int SignTx::kLockTimeFieldNumber;
const int SignTx::kExpiryFieldNumber;
const int SignTx::kOverwinteredFieldNumber;
#endif  // !_MSC_VER

SignTx::SignTx()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SignTx)
}

void SignTx::InitAsDefaultInstance() {
}

SignTx::SignTx(const SignTx& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:SignTx)
}

void SignTx::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  outputs_count_ = 0u;
  inputs_count_ = 0u;
  coin_name_ = const_cast< ::std::string*>(_default_coin_name_);
  version_ = 1u;
  lock_time_ = 0u;
  expiry_ = 0u;
  overwintered_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SignTx::~SignTx() {
  // @@protoc_insertion_point(destructor:SignTx)
  SharedDtor();
}

void SignTx::SharedDtor() {
  if (coin_name_ != _default_coin_name_) {
    delete coin_name_;
  }
  if (this != default_instance_) {
  }
}

void SignTx::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SignTx::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SignTx_descriptor_;
}

const SignTx& SignTx::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2dbitcoin_2eproto();
  return *default_instance_;
}

SignTx* SignTx::default_instance_ = NULL;

SignTx* SignTx::New() const {
  return new SignTx;
}

void SignTx::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<SignTx*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 127) {
    ZR_(outputs_count_, inputs_count_);
    ZR_(lock_time_, overwintered_);
    if (has_coin_name()) {
      if (coin_name_ != _default_coin_name_) {
        coin_name_->assign(*_default_coin_name_);
      }
    }
    version_ = 1u;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SignTx::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:SignTx)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 outputs_count = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &outputs_count_)));
          set_has_outputs_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_inputs_count;
        break;
      }

      // required uint32 inputs_count = 2;
      case 2: {
        if (tag == 16) {
         parse_inputs_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &inputs_count_)));
          set_has_inputs_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_coin_name;
        break;
      }

      // optional string coin_name = 3 [default = "Bitcoin"];
      case 3: {
        if (tag == 26) {
         parse_coin_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_coin_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->coin_name().data(), this->coin_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "coin_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_version;
        break;
      }

      // optional uint32 version = 4 [default = 1];
      case 4: {
        if (tag == 32) {
         parse_version:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &version_)));
          set_has_version();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_lock_time;
        break;
      }

      // optional uint32 lock_time = 5 [default = 0];
      case 5: {
        if (tag == 40) {
         parse_lock_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &lock_time_)));
          set_has_lock_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_expiry;
        break;
      }

      // optional uint32 expiry = 6;
      case 6: {
        if (tag == 48) {
         parse_expiry:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &expiry_)));
          set_has_expiry();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_overwintered;
        break;
      }

      // optional bool overwintered = 7;
      case 7: {
        if (tag == 56) {
         parse_overwintered:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &overwintered_)));
          set_has_overwintered();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:SignTx)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:SignTx)
  return false;
#undef DO_
}

void SignTx::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:SignTx)
  // required uint32 outputs_count = 1;
  if (has_outputs_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->outputs_count(), output);
  }

  // required uint32 inputs_count = 2;
  if (has_inputs_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->inputs_count(), output);
  }

  // optional string coin_name = 3 [default = "Bitcoin"];
  if (has_coin_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->coin_name().data(), this->coin_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "coin_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->coin_name(), output);
  }

  // optional uint32 version = 4 [default = 1];
  if (has_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->version(), output);
  }

  // optional uint32 lock_time = 5 [default = 0];
  if (has_lock_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->lock_time(), output);
  }

  // optional uint32 expiry = 6;
  if (has_expiry()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->expiry(), output);
  }

  // optional bool overwintered = 7;
  if (has_overwintered()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->overwintered(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:SignTx)
}

::google::protobuf::uint8* SignTx::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:SignTx)
  // required uint32 outputs_count = 1;
  if (has_outputs_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->outputs_count(), target);
  }

  // required uint32 inputs_count = 2;
  if (has_inputs_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->inputs_count(), target);
  }

  // optional string coin_name = 3 [default = "Bitcoin"];
  if (has_coin_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->coin_name().data(), this->coin_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "coin_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->coin_name(), target);
  }

  // optional uint32 version = 4 [default = 1];
  if (has_version()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->version(), target);
  }

  // optional uint32 lock_time = 5 [default = 0];
  if (has_lock_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->lock_time(), target);
  }

  // optional uint32 expiry = 6;
  if (has_expiry()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->expiry(), target);
  }

  // optional bool overwintered = 7;
  if (has_overwintered()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(7, this->overwintered(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SignTx)
  return target;
}

int SignTx::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 outputs_count = 1;
    if (has_outputs_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->outputs_count());
    }

    // required uint32 inputs_count = 2;
    if (has_inputs_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->inputs_count());
    }

    // optional string coin_name = 3 [default = "Bitcoin"];
    if (has_coin_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->coin_name());
    }

    // optional uint32 version = 4 [default = 1];
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->version());
    }

    // optional uint32 lock_time = 5 [default = 0];
    if (has_lock_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->lock_time());
    }

    // optional uint32 expiry = 6;
    if (has_expiry()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->expiry());
    }

    // optional bool overwintered = 7;
    if (has_overwintered()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SignTx::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SignTx* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SignTx*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SignTx::MergeFrom(const SignTx& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_outputs_count()) {
      set_outputs_count(from.outputs_count());
    }
    if (from.has_inputs_count()) {
      set_inputs_count(from.inputs_count());
    }
    if (from.has_coin_name()) {
      set_coin_name(from.coin_name());
    }
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_lock_time()) {
      set_lock_time(from.lock_time());
    }
    if (from.has_expiry()) {
      set_expiry(from.expiry());
    }
    if (from.has_overwintered()) {
      set_overwintered(from.overwintered());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SignTx::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SignTx::CopyFrom(const SignTx& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SignTx::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void SignTx::Swap(SignTx* other) {
  if (other != this) {
    std::swap(outputs_count_, other->outputs_count_);
    std::swap(inputs_count_, other->inputs_count_);
    std::swap(coin_name_, other->coin_name_);
    std::swap(version_, other->version_);
    std::swap(lock_time_, other->lock_time_);
    std::swap(expiry_, other->expiry_);
    std::swap(overwintered_, other->overwintered_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SignTx::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SignTx_descriptor_;
  metadata.reflection = SignTx_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* TxRequest_RequestType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TxRequest_RequestType_descriptor_;
}
bool TxRequest_RequestType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const TxRequest_RequestType TxRequest::TXINPUT;
const TxRequest_RequestType TxRequest::TXOUTPUT;
const TxRequest_RequestType TxRequest::TXMETA;
const TxRequest_RequestType TxRequest::TXFINISHED;
const TxRequest_RequestType TxRequest::TXEXTRADATA;
const TxRequest_RequestType TxRequest::RequestType_MIN;
const TxRequest_RequestType TxRequest::RequestType_MAX;
const int TxRequest::RequestType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int TxRequest_TxRequestDetailsType::kRequestIndexFieldNumber;
const int TxRequest_TxRequestDetailsType::kTxHashFieldNumber;
const int TxRequest_TxRequestDetailsType::kExtraDataLenFieldNumber;
const int TxRequest_TxRequestDetailsType::kExtraDataOffsetFieldNumber;
#endif  // !_MSC_VER

TxRequest_TxRequestDetailsType::TxRequest_TxRequestDetailsType()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:TxRequest.TxRequestDetailsType)
}

void TxRequest_TxRequestDetailsType::InitAsDefaultInstance() {
}

TxRequest_TxRequestDetailsType::TxRequest_TxRequestDetailsType(const TxRequest_TxRequestDetailsType& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:TxRequest.TxRequestDetailsType)
}

void TxRequest_TxRequestDetailsType::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  request_index_ = 0u;
  tx_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  extra_data_len_ = 0u;
  extra_data_offset_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TxRequest_TxRequestDetailsType::~TxRequest_TxRequestDetailsType() {
  // @@protoc_insertion_point(destructor:TxRequest.TxRequestDetailsType)
  SharedDtor();
}

void TxRequest_TxRequestDetailsType::SharedDtor() {
  if (tx_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tx_hash_;
  }
  if (this != default_instance_) {
  }
}

void TxRequest_TxRequestDetailsType::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TxRequest_TxRequestDetailsType::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TxRequest_TxRequestDetailsType_descriptor_;
}

const TxRequest_TxRequestDetailsType& TxRequest_TxRequestDetailsType::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2dbitcoin_2eproto();
  return *default_instance_;
}

TxRequest_TxRequestDetailsType* TxRequest_TxRequestDetailsType::default_instance_ = NULL;

TxRequest_TxRequestDetailsType* TxRequest_TxRequestDetailsType::New() const {
  return new TxRequest_TxRequestDetailsType;
}

void TxRequest_TxRequestDetailsType::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<TxRequest_TxRequestDetailsType*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 15) {
    ZR_(request_index_, extra_data_offset_);
    if (has_tx_hash()) {
      if (tx_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        tx_hash_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TxRequest_TxRequestDetailsType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TxRequest.TxRequestDetailsType)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 request_index = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &request_index_)));
          set_has_request_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_tx_hash;
        break;
      }

      // optional bytes tx_hash = 2;
      case 2: {
        if (tag == 18) {
         parse_tx_hash:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_tx_hash()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_extra_data_len;
        break;
      }

      // optional uint32 extra_data_len = 3;
      case 3: {
        if (tag == 24) {
         parse_extra_data_len:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &extra_data_len_)));
          set_has_extra_data_len();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_extra_data_offset;
        break;
      }

      // optional uint32 extra_data_offset = 4;
      case 4: {
        if (tag == 32) {
         parse_extra_data_offset:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &extra_data_offset_)));
          set_has_extra_data_offset();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TxRequest.TxRequestDetailsType)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TxRequest.TxRequestDetailsType)
  return false;
#undef DO_
}

void TxRequest_TxRequestDetailsType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TxRequest.TxRequestDetailsType)
  // optional uint32 request_index = 1;
  if (has_request_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->request_index(), output);
  }

  // optional bytes tx_hash = 2;
  if (has_tx_hash()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->tx_hash(), output);
  }

  // optional uint32 extra_data_len = 3;
  if (has_extra_data_len()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->extra_data_len(), output);
  }

  // optional uint32 extra_data_offset = 4;
  if (has_extra_data_offset()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->extra_data_offset(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TxRequest.TxRequestDetailsType)
}

::google::protobuf::uint8* TxRequest_TxRequestDetailsType::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TxRequest.TxRequestDetailsType)
  // optional uint32 request_index = 1;
  if (has_request_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->request_index(), target);
  }

  // optional bytes tx_hash = 2;
  if (has_tx_hash()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->tx_hash(), target);
  }

  // optional uint32 extra_data_len = 3;
  if (has_extra_data_len()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->extra_data_len(), target);
  }

  // optional uint32 extra_data_offset = 4;
  if (has_extra_data_offset()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->extra_data_offset(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TxRequest.TxRequestDetailsType)
  return target;
}

int TxRequest_TxRequestDetailsType::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 request_index = 1;
    if (has_request_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->request_index());
    }

    // optional bytes tx_hash = 2;
    if (has_tx_hash()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->tx_hash());
    }

    // optional uint32 extra_data_len = 3;
    if (has_extra_data_len()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->extra_data_len());
    }

    // optional uint32 extra_data_offset = 4;
    if (has_extra_data_offset()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->extra_data_offset());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TxRequest_TxRequestDetailsType::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TxRequest_TxRequestDetailsType* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TxRequest_TxRequestDetailsType*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TxRequest_TxRequestDetailsType::MergeFrom(const TxRequest_TxRequestDetailsType& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_request_index()) {
      set_request_index(from.request_index());
    }
    if (from.has_tx_hash()) {
      set_tx_hash(from.tx_hash());
    }
    if (from.has_extra_data_len()) {
      set_extra_data_len(from.extra_data_len());
    }
    if (from.has_extra_data_offset()) {
      set_extra_data_offset(from.extra_data_offset());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TxRequest_TxRequestDetailsType::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TxRequest_TxRequestDetailsType::CopyFrom(const TxRequest_TxRequestDetailsType& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TxRequest_TxRequestDetailsType::IsInitialized() const {

  return true;
}

void TxRequest_TxRequestDetailsType::Swap(TxRequest_TxRequestDetailsType* other) {
  if (other != this) {
    std::swap(request_index_, other->request_index_);
    std::swap(tx_hash_, other->tx_hash_);
    std::swap(extra_data_len_, other->extra_data_len_);
    std::swap(extra_data_offset_, other->extra_data_offset_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TxRequest_TxRequestDetailsType::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TxRequest_TxRequestDetailsType_descriptor_;
  metadata.reflection = TxRequest_TxRequestDetailsType_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int TxRequest_TxRequestSerializedType::kSignatureIndexFieldNumber;
const int TxRequest_TxRequestSerializedType::kSignatureFieldNumber;
const int TxRequest_TxRequestSerializedType::kSerializedTxFieldNumber;
#endif  // !_MSC_VER

TxRequest_TxRequestSerializedType::TxRequest_TxRequestSerializedType()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:TxRequest.TxRequestSerializedType)
}

void TxRequest_TxRequestSerializedType::InitAsDefaultInstance() {
}

TxRequest_TxRequestSerializedType::TxRequest_TxRequestSerializedType(const TxRequest_TxRequestSerializedType& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:TxRequest.TxRequestSerializedType)
}

void TxRequest_TxRequestSerializedType::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  signature_index_ = 0u;
  signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  serialized_tx_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TxRequest_TxRequestSerializedType::~TxRequest_TxRequestSerializedType() {
  // @@protoc_insertion_point(destructor:TxRequest.TxRequestSerializedType)
  SharedDtor();
}

void TxRequest_TxRequestSerializedType::SharedDtor() {
  if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete signature_;
  }
  if (serialized_tx_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete serialized_tx_;
  }
  if (this != default_instance_) {
  }
}

void TxRequest_TxRequestSerializedType::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TxRequest_TxRequestSerializedType::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TxRequest_TxRequestSerializedType_descriptor_;
}

const TxRequest_TxRequestSerializedType& TxRequest_TxRequestSerializedType::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2dbitcoin_2eproto();
  return *default_instance_;
}

TxRequest_TxRequestSerializedType* TxRequest_TxRequestSerializedType::default_instance_ = NULL;

TxRequest_TxRequestSerializedType* TxRequest_TxRequestSerializedType::New() const {
  return new TxRequest_TxRequestSerializedType;
}

void TxRequest_TxRequestSerializedType::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    signature_index_ = 0u;
    if (has_signature()) {
      if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        signature_->clear();
      }
    }
    if (has_serialized_tx()) {
      if (serialized_tx_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        serialized_tx_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TxRequest_TxRequestSerializedType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TxRequest.TxRequestSerializedType)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 signature_index = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &signature_index_)));
          set_has_signature_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_signature;
        break;
      }

      // optional bytes signature = 2;
      case 2: {
        if (tag == 18) {
         parse_signature:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_signature()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_serialized_tx;
        break;
      }

      // optional bytes serialized_tx = 3;
      case 3: {
        if (tag == 26) {
         parse_serialized_tx:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_serialized_tx()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TxRequest.TxRequestSerializedType)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TxRequest.TxRequestSerializedType)
  return false;
#undef DO_
}

void TxRequest_TxRequestSerializedType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TxRequest.TxRequestSerializedType)
  // optional uint32 signature_index = 1;
  if (has_signature_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->signature_index(), output);
  }

  // optional bytes signature = 2;
  if (has_signature()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->signature(), output);
  }

  // optional bytes serialized_tx = 3;
  if (has_serialized_tx()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->serialized_tx(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TxRequest.TxRequestSerializedType)
}

::google::protobuf::uint8* TxRequest_TxRequestSerializedType::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TxRequest.TxRequestSerializedType)
  // optional uint32 signature_index = 1;
  if (has_signature_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->signature_index(), target);
  }

  // optional bytes signature = 2;
  if (has_signature()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->signature(), target);
  }

  // optional bytes serialized_tx = 3;
  if (has_serialized_tx()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->serialized_tx(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TxRequest.TxRequestSerializedType)
  return target;
}

int TxRequest_TxRequestSerializedType::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 signature_index = 1;
    if (has_signature_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->signature_index());
    }

    // optional bytes signature = 2;
    if (has_signature()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->signature());
    }

    // optional bytes serialized_tx = 3;
    if (has_serialized_tx()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->serialized_tx());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TxRequest_TxRequestSerializedType::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TxRequest_TxRequestSerializedType* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TxRequest_TxRequestSerializedType*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TxRequest_TxRequestSerializedType::MergeFrom(const TxRequest_TxRequestSerializedType& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_signature_index()) {
      set_signature_index(from.signature_index());
    }
    if (from.has_signature()) {
      set_signature(from.signature());
    }
    if (from.has_serialized_tx()) {
      set_serialized_tx(from.serialized_tx());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TxRequest_TxRequestSerializedType::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TxRequest_TxRequestSerializedType::CopyFrom(const TxRequest_TxRequestSerializedType& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TxRequest_TxRequestSerializedType::IsInitialized() const {

  return true;
}

void TxRequest_TxRequestSerializedType::Swap(TxRequest_TxRequestSerializedType* other) {
  if (other != this) {
    std::swap(signature_index_, other->signature_index_);
    std::swap(signature_, other->signature_);
    std::swap(serialized_tx_, other->serialized_tx_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TxRequest_TxRequestSerializedType::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TxRequest_TxRequestSerializedType_descriptor_;
  metadata.reflection = TxRequest_TxRequestSerializedType_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int TxRequest::kRequestTypeFieldNumber;
const int TxRequest::kDetailsFieldNumber;
const int TxRequest::kSerializedFieldNumber;
#endif  // !_MSC_VER

TxRequest::TxRequest()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:TxRequest)
}

void TxRequest::InitAsDefaultInstance() {
  details_ = const_cast< ::TxRequest_TxRequestDetailsType*>(&::TxRequest_TxRequestDetailsType::default_instance());
  serialized_ = const_cast< ::TxRequest_TxRequestSerializedType*>(&::TxRequest_TxRequestSerializedType::default_instance());
}

TxRequest::TxRequest(const TxRequest& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:TxRequest)
}

void TxRequest::SharedCtor() {
  _cached_size_ = 0;
  request_type_ = 0;
  details_ = NULL;
  serialized_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TxRequest::~TxRequest() {
  // @@protoc_insertion_point(destructor:TxRequest)
  SharedDtor();
}

void TxRequest::SharedDtor() {
  if (this != default_instance_) {
    delete details_;
    delete serialized_;
  }
}

void TxRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TxRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TxRequest_descriptor_;
}

const TxRequest& TxRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2dbitcoin_2eproto();
  return *default_instance_;
}

TxRequest* TxRequest::default_instance_ = NULL;

TxRequest* TxRequest::New() const {
  return new TxRequest;
}

void TxRequest::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    request_type_ = 0;
    if (has_details()) {
      if (details_ != NULL) details_->::TxRequest_TxRequestDetailsType::Clear();
    }
    if (has_serialized()) {
      if (serialized_ != NULL) serialized_->::TxRequest_TxRequestSerializedType::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TxRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TxRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .TxRequest.RequestType request_type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::TxRequest_RequestType_IsValid(value)) {
            set_request_type(static_cast< ::TxRequest_RequestType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_details;
        break;
      }

      // optional .TxRequest.TxRequestDetailsType details = 2;
      case 2: {
        if (tag == 18) {
         parse_details:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_details()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_serialized;
        break;
      }

      // optional .TxRequest.TxRequestSerializedType serialized = 3;
      case 3: {
        if (tag == 26) {
         parse_serialized:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_serialized()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TxRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TxRequest)
  return false;
#undef DO_
}

void TxRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TxRequest)
  // optional .TxRequest.RequestType request_type = 1;
  if (has_request_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->request_type(), output);
  }

  // optional .TxRequest.TxRequestDetailsType details = 2;
  if (has_details()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->details(), output);
  }

  // optional .TxRequest.TxRequestSerializedType serialized = 3;
  if (has_serialized()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->serialized(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TxRequest)
}

::google::protobuf::uint8* TxRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TxRequest)
  // optional .TxRequest.RequestType request_type = 1;
  if (has_request_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->request_type(), target);
  }

  // optional .TxRequest.TxRequestDetailsType details = 2;
  if (has_details()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->details(), target);
  }

  // optional .TxRequest.TxRequestSerializedType serialized = 3;
  if (has_serialized()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->serialized(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TxRequest)
  return target;
}

int TxRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .TxRequest.RequestType request_type = 1;
    if (has_request_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->request_type());
    }

    // optional .TxRequest.TxRequestDetailsType details = 2;
    if (has_details()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->details());
    }

    // optional .TxRequest.TxRequestSerializedType serialized = 3;
    if (has_serialized()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->serialized());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TxRequest::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TxRequest* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TxRequest*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TxRequest::MergeFrom(const TxRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_request_type()) {
      set_request_type(from.request_type());
    }
    if (from.has_details()) {
      mutable_details()->::TxRequest_TxRequestDetailsType::MergeFrom(from.details());
    }
    if (from.has_serialized()) {
      mutable_serialized()->::TxRequest_TxRequestSerializedType::MergeFrom(from.serialized());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TxRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TxRequest::CopyFrom(const TxRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TxRequest::IsInitialized() const {

  return true;
}

void TxRequest::Swap(TxRequest* other) {
  if (other != this) {
    std::swap(request_type_, other->request_type_);
    std::swap(details_, other->details_);
    std::swap(serialized_, other->serialized_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TxRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TxRequest_descriptor_;
  metadata.reflection = TxRequest_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TxAck_TransactionType_TxInputType::kAddressNFieldNumber;
const int TxAck_TransactionType_TxInputType::kPrevHashFieldNumber;
const int TxAck_TransactionType_TxInputType::kPrevIndexFieldNumber;
const int TxAck_TransactionType_TxInputType::kScriptSigFieldNumber;
const int TxAck_TransactionType_TxInputType::kSequenceFieldNumber;
const int TxAck_TransactionType_TxInputType::kScriptTypeFieldNumber;
const int TxAck_TransactionType_TxInputType::kMultisigFieldNumber;
const int TxAck_TransactionType_TxInputType::kAmountFieldNumber;
const int TxAck_TransactionType_TxInputType::kDecredTreeFieldNumber;
const int TxAck_TransactionType_TxInputType::kDecredScriptVersionFieldNumber;
const int TxAck_TransactionType_TxInputType::kPrevBlockHashBip115FieldNumber;
const int TxAck_TransactionType_TxInputType::kPrevBlockHeightBip115FieldNumber;
#endif  // !_MSC_VER

TxAck_TransactionType_TxInputType::TxAck_TransactionType_TxInputType()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:TxAck.TransactionType.TxInputType)
}

void TxAck_TransactionType_TxInputType::InitAsDefaultInstance() {
  multisig_ = const_cast< ::MultisigRedeemScriptType*>(&::MultisigRedeemScriptType::default_instance());
}

TxAck_TransactionType_TxInputType::TxAck_TransactionType_TxInputType(const TxAck_TransactionType_TxInputType& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:TxAck.TransactionType.TxInputType)
}

void TxAck_TransactionType_TxInputType::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  prev_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  prev_index_ = 0u;
  script_sig_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  sequence_ = 4294967295u;
  script_type_ = 0;
  multisig_ = NULL;
  amount_ = GOOGLE_ULONGLONG(0);
  decred_tree_ = 0u;
  decred_script_version_ = 0u;
  prev_block_hash_bip115_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  prev_block_height_bip115_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TxAck_TransactionType_TxInputType::~TxAck_TransactionType_TxInputType() {
  // @@protoc_insertion_point(destructor:TxAck.TransactionType.TxInputType)
  SharedDtor();
}

void TxAck_TransactionType_TxInputType::SharedDtor() {
  if (prev_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete prev_hash_;
  }
  if (script_sig_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete script_sig_;
  }
  if (prev_block_hash_bip115_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete prev_block_hash_bip115_;
  }
  if (this != default_instance_) {
    delete multisig_;
  }
}

void TxAck_TransactionType_TxInputType::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TxAck_TransactionType_TxInputType::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TxAck_TransactionType_TxInputType_descriptor_;
}

const TxAck_TransactionType_TxInputType& TxAck_TransactionType_TxInputType::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2dbitcoin_2eproto();
  return *default_instance_;
}

TxAck_TransactionType_TxInputType* TxAck_TransactionType_TxInputType::default_instance_ = NULL;

TxAck_TransactionType_TxInputType* TxAck_TransactionType_TxInputType::New() const {
  return new TxAck_TransactionType_TxInputType;
}

void TxAck_TransactionType_TxInputType::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<TxAck_TransactionType_TxInputType*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 254) {
    if (has_prev_hash()) {
      if (prev_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        prev_hash_->clear();
      }
    }
    prev_index_ = 0u;
    if (has_script_sig()) {
      if (script_sig_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        script_sig_->clear();
      }
    }
    sequence_ = 4294967295u;
    script_type_ = 0;
    if (has_multisig()) {
      if (multisig_ != NULL) multisig_->::MultisigRedeemScriptType::Clear();
    }
    amount_ = GOOGLE_ULONGLONG(0);
  }
  if (_has_bits_[8 / 32] & 3840) {
    ZR_(decred_script_version_, prev_block_height_bip115_);
    decred_tree_ = 0u;
    if (has_prev_block_hash_bip115()) {
      if (prev_block_hash_bip115_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        prev_block_hash_bip115_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  address_n_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TxAck_TransactionType_TxInputType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TxAck.TransactionType.TxInputType)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 address_n = 1;
      case 1: {
        if (tag == 8) {
         parse_address_n:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8, input, this->mutable_address_n())));
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_address_n())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(8)) goto parse_address_n;
        if (input->ExpectTag(18)) goto parse_prev_hash;
        break;
      }

      // required bytes prev_hash = 2;
      case 2: {
        if (tag == 18) {
         parse_prev_hash:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_prev_hash()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_prev_index;
        break;
      }

      // required uint32 prev_index = 3;
      case 3: {
        if (tag == 24) {
         parse_prev_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &prev_index_)));
          set_has_prev_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_script_sig;
        break;
      }

      // optional bytes script_sig = 4;
      case 4: {
        if (tag == 34) {
         parse_script_sig:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_script_sig()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_sequence;
        break;
      }

      // optional uint32 sequence = 5 [default = 4294967295];
      case 5: {
        if (tag == 40) {
         parse_sequence:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sequence_)));
          set_has_sequence();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_script_type;
        break;
      }

      // optional .InputScriptType script_type = 6 [default = SPENDADDRESS];
      case 6: {
        if (tag == 48) {
         parse_script_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::InputScriptType_IsValid(value)) {
            set_script_type(static_cast< ::InputScriptType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(6, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_multisig;
        break;
      }

      // optional .MultisigRedeemScriptType multisig = 7;
      case 7: {
        if (tag == 58) {
         parse_multisig:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_multisig()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_amount;
        break;
      }

      // optional uint64 amount = 8;
      case 8: {
        if (tag == 64) {
         parse_amount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &amount_)));
          set_has_amount();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_decred_tree;
        break;
      }

      // optional uint32 decred_tree = 9;
      case 9: {
        if (tag == 72) {
         parse_decred_tree:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &decred_tree_)));
          set_has_decred_tree();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_decred_script_version;
        break;
      }

      // optional uint32 decred_script_version = 10;
      case 10: {
        if (tag == 80) {
         parse_decred_script_version:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &decred_script_version_)));
          set_has_decred_script_version();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_prev_block_hash_bip115;
        break;
      }

      // optional bytes prev_block_hash_bip115 = 11;
      case 11: {
        if (tag == 90) {
         parse_prev_block_hash_bip115:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_prev_block_hash_bip115()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_prev_block_height_bip115;
        break;
      }

      // optional uint32 prev_block_height_bip115 = 12;
      case 12: {
        if (tag == 96) {
         parse_prev_block_height_bip115:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &prev_block_height_bip115_)));
          set_has_prev_block_height_bip115();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TxAck.TransactionType.TxInputType)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TxAck.TransactionType.TxInputType)
  return false;
#undef DO_
}

void TxAck_TransactionType_TxInputType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TxAck.TransactionType.TxInputType)
  // repeated uint32 address_n = 1;
  for (int i = 0; i < this->address_n_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->address_n(i), output);
  }

  // required bytes prev_hash = 2;
  if (has_prev_hash()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->prev_hash(), output);
  }

  // required uint32 prev_index = 3;
  if (has_prev_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->prev_index(), output);
  }

  // optional bytes script_sig = 4;
  if (has_script_sig()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->script_sig(), output);
  }

  // optional uint32 sequence = 5 [default = 4294967295];
  if (has_sequence()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->sequence(), output);
  }

  // optional .InputScriptType script_type = 6 [default = SPENDADDRESS];
  if (has_script_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      6, this->script_type(), output);
  }

  // optional .MultisigRedeemScriptType multisig = 7;
  if (has_multisig()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->multisig(), output);
  }

  // optional uint64 amount = 8;
  if (has_amount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(8, this->amount(), output);
  }

  // optional uint32 decred_tree = 9;
  if (has_decred_tree()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->decred_tree(), output);
  }

  // optional uint32 decred_script_version = 10;
  if (has_decred_script_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->decred_script_version(), output);
  }

  // optional bytes prev_block_hash_bip115 = 11;
  if (has_prev_block_hash_bip115()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      11, this->prev_block_hash_bip115(), output);
  }

  // optional uint32 prev_block_height_bip115 = 12;
  if (has_prev_block_height_bip115()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(12, this->prev_block_height_bip115(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TxAck.TransactionType.TxInputType)
}

::google::protobuf::uint8* TxAck_TransactionType_TxInputType::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TxAck.TransactionType.TxInputType)
  // repeated uint32 address_n = 1;
  for (int i = 0; i < this->address_n_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(1, this->address_n(i), target);
  }

  // required bytes prev_hash = 2;
  if (has_prev_hash()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->prev_hash(), target);
  }

  // required uint32 prev_index = 3;
  if (has_prev_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->prev_index(), target);
  }

  // optional bytes script_sig = 4;
  if (has_script_sig()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->script_sig(), target);
  }

  // optional uint32 sequence = 5 [default = 4294967295];
  if (has_sequence()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->sequence(), target);
  }

  // optional .InputScriptType script_type = 6 [default = SPENDADDRESS];
  if (has_script_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      6, this->script_type(), target);
  }

  // optional .MultisigRedeemScriptType multisig = 7;
  if (has_multisig()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->multisig(), target);
  }

  // optional uint64 amount = 8;
  if (has_amount()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(8, this->amount(), target);
  }

  // optional uint32 decred_tree = 9;
  if (has_decred_tree()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(9, this->decred_tree(), target);
  }

  // optional uint32 decred_script_version = 10;
  if (has_decred_script_version()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(10, this->decred_script_version(), target);
  }

  // optional bytes prev_block_hash_bip115 = 11;
  if (has_prev_block_hash_bip115()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        11, this->prev_block_hash_bip115(), target);
  }

  // optional uint32 prev_block_height_bip115 = 12;
  if (has_prev_block_height_bip115()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(12, this->prev_block_height_bip115(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TxAck.TransactionType.TxInputType)
  return target;
}

int TxAck_TransactionType_TxInputType::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // required bytes prev_hash = 2;
    if (has_prev_hash()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->prev_hash());
    }

    // required uint32 prev_index = 3;
    if (has_prev_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->prev_index());
    }

    // optional bytes script_sig = 4;
    if (has_script_sig()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->script_sig());
    }

    // optional uint32 sequence = 5 [default = 4294967295];
    if (has_sequence()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sequence());
    }

    // optional .InputScriptType script_type = 6 [default = SPENDADDRESS];
    if (has_script_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->script_type());
    }

    // optional .MultisigRedeemScriptType multisig = 7;
    if (has_multisig()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->multisig());
    }

    // optional uint64 amount = 8;
    if (has_amount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->amount());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional uint32 decred_tree = 9;
    if (has_decred_tree()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->decred_tree());
    }

    // optional uint32 decred_script_version = 10;
    if (has_decred_script_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->decred_script_version());
    }

    // optional bytes prev_block_hash_bip115 = 11;
    if (has_prev_block_hash_bip115()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->prev_block_hash_bip115());
    }

    // optional uint32 prev_block_height_bip115 = 12;
    if (has_prev_block_height_bip115()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->prev_block_height_bip115());
    }

  }
  // repeated uint32 address_n = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->address_n_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->address_n(i));
    }
    total_size += 1 * this->address_n_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TxAck_TransactionType_TxInputType::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TxAck_TransactionType_TxInputType* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TxAck_TransactionType_TxInputType*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TxAck_TransactionType_TxInputType::MergeFrom(const TxAck_TransactionType_TxInputType& from) {
  GOOGLE_CHECK_NE(&from, this);
  address_n_.MergeFrom(from.address_n_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_prev_hash()) {
      set_prev_hash(from.prev_hash());
    }
    if (from.has_prev_index()) {
      set_prev_index(from.prev_index());
    }
    if (from.has_script_sig()) {
      set_script_sig(from.script_sig());
    }
    if (from.has_sequence()) {
      set_sequence(from.sequence());
    }
    if (from.has_script_type()) {
      set_script_type(from.script_type());
    }
    if (from.has_multisig()) {
      mutable_multisig()->::MultisigRedeemScriptType::MergeFrom(from.multisig());
    }
    if (from.has_amount()) {
      set_amount(from.amount());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_decred_tree()) {
      set_decred_tree(from.decred_tree());
    }
    if (from.has_decred_script_version()) {
      set_decred_script_version(from.decred_script_version());
    }
    if (from.has_prev_block_hash_bip115()) {
      set_prev_block_hash_bip115(from.prev_block_hash_bip115());
    }
    if (from.has_prev_block_height_bip115()) {
      set_prev_block_height_bip115(from.prev_block_height_bip115());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TxAck_TransactionType_TxInputType::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TxAck_TransactionType_TxInputType::CopyFrom(const TxAck_TransactionType_TxInputType& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TxAck_TransactionType_TxInputType::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000006) != 0x00000006) return false;

  if (has_multisig()) {
    if (!this->multisig().IsInitialized()) return false;
  }
  return true;
}

void TxAck_TransactionType_TxInputType::Swap(TxAck_TransactionType_TxInputType* other) {
  if (other != this) {
    address_n_.Swap(&other->address_n_);
    std::swap(prev_hash_, other->prev_hash_);
    std::swap(prev_index_, other->prev_index_);
    std::swap(script_sig_, other->script_sig_);
    std::swap(sequence_, other->sequence_);
    std::swap(script_type_, other->script_type_);
    std::swap(multisig_, other->multisig_);
    std::swap(amount_, other->amount_);
    std::swap(decred_tree_, other->decred_tree_);
    std::swap(decred_script_version_, other->decred_script_version_);
    std::swap(prev_block_hash_bip115_, other->prev_block_hash_bip115_);
    std::swap(prev_block_height_bip115_, other->prev_block_height_bip115_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TxAck_TransactionType_TxInputType::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TxAck_TransactionType_TxInputType_descriptor_;
  metadata.reflection = TxAck_TransactionType_TxInputType_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int TxAck_TransactionType_TxOutputBinType::kAmountFieldNumber;
const int TxAck_TransactionType_TxOutputBinType::kScriptPubkeyFieldNumber;
const int TxAck_TransactionType_TxOutputBinType::kDecredScriptVersionFieldNumber;
#endif  // !_MSC_VER

TxAck_TransactionType_TxOutputBinType::TxAck_TransactionType_TxOutputBinType()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:TxAck.TransactionType.TxOutputBinType)
}

void TxAck_TransactionType_TxOutputBinType::InitAsDefaultInstance() {
}

TxAck_TransactionType_TxOutputBinType::TxAck_TransactionType_TxOutputBinType(const TxAck_TransactionType_TxOutputBinType& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:TxAck.TransactionType.TxOutputBinType)
}

void TxAck_TransactionType_TxOutputBinType::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  amount_ = GOOGLE_ULONGLONG(0);
  script_pubkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  decred_script_version_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TxAck_TransactionType_TxOutputBinType::~TxAck_TransactionType_TxOutputBinType() {
  // @@protoc_insertion_point(destructor:TxAck.TransactionType.TxOutputBinType)
  SharedDtor();
}

void TxAck_TransactionType_TxOutputBinType::SharedDtor() {
  if (script_pubkey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete script_pubkey_;
  }
  if (this != default_instance_) {
  }
}

void TxAck_TransactionType_TxOutputBinType::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TxAck_TransactionType_TxOutputBinType::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TxAck_TransactionType_TxOutputBinType_descriptor_;
}

const TxAck_TransactionType_TxOutputBinType& TxAck_TransactionType_TxOutputBinType::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2dbitcoin_2eproto();
  return *default_instance_;
}

TxAck_TransactionType_TxOutputBinType* TxAck_TransactionType_TxOutputBinType::default_instance_ = NULL;

TxAck_TransactionType_TxOutputBinType* TxAck_TransactionType_TxOutputBinType::New() const {
  return new TxAck_TransactionType_TxOutputBinType;
}

void TxAck_TransactionType_TxOutputBinType::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    amount_ = GOOGLE_ULONGLONG(0);
    if (has_script_pubkey()) {
      if (script_pubkey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        script_pubkey_->clear();
      }
    }
    decred_script_version_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TxAck_TransactionType_TxOutputBinType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TxAck.TransactionType.TxOutputBinType)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 amount = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &amount_)));
          set_has_amount();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_script_pubkey;
        break;
      }

      // required bytes script_pubkey = 2;
      case 2: {
        if (tag == 18) {
         parse_script_pubkey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_script_pubkey()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_decred_script_version;
        break;
      }

      // optional uint32 decred_script_version = 3;
      case 3: {
        if (tag == 24) {
         parse_decred_script_version:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &decred_script_version_)));
          set_has_decred_script_version();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TxAck.TransactionType.TxOutputBinType)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TxAck.TransactionType.TxOutputBinType)
  return false;
#undef DO_
}

void TxAck_TransactionType_TxOutputBinType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TxAck.TransactionType.TxOutputBinType)
  // required uint64 amount = 1;
  if (has_amount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->amount(), output);
  }

  // required bytes script_pubkey = 2;
  if (has_script_pubkey()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->script_pubkey(), output);
  }

  // optional uint32 decred_script_version = 3;
  if (has_decred_script_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->decred_script_version(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TxAck.TransactionType.TxOutputBinType)
}

::google::protobuf::uint8* TxAck_TransactionType_TxOutputBinType::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TxAck.TransactionType.TxOutputBinType)
  // required uint64 amount = 1;
  if (has_amount()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->amount(), target);
  }

  // required bytes script_pubkey = 2;
  if (has_script_pubkey()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->script_pubkey(), target);
  }

  // optional uint32 decred_script_version = 3;
  if (has_decred_script_version()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->decred_script_version(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TxAck.TransactionType.TxOutputBinType)
  return target;
}

int TxAck_TransactionType_TxOutputBinType::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 amount = 1;
    if (has_amount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->amount());
    }

    // required bytes script_pubkey = 2;
    if (has_script_pubkey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->script_pubkey());
    }

    // optional uint32 decred_script_version = 3;
    if (has_decred_script_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->decred_script_version());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TxAck_TransactionType_TxOutputBinType::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TxAck_TransactionType_TxOutputBinType* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TxAck_TransactionType_TxOutputBinType*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TxAck_TransactionType_TxOutputBinType::MergeFrom(const TxAck_TransactionType_TxOutputBinType& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_amount()) {
      set_amount(from.amount());
    }
    if (from.has_script_pubkey()) {
      set_script_pubkey(from.script_pubkey());
    }
    if (from.has_decred_script_version()) {
      set_decred_script_version(from.decred_script_version());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TxAck_TransactionType_TxOutputBinType::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TxAck_TransactionType_TxOutputBinType::CopyFrom(const TxAck_TransactionType_TxOutputBinType& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TxAck_TransactionType_TxOutputBinType::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void TxAck_TransactionType_TxOutputBinType::Swap(TxAck_TransactionType_TxOutputBinType* other) {
  if (other != this) {
    std::swap(amount_, other->amount_);
    std::swap(script_pubkey_, other->script_pubkey_);
    std::swap(decred_script_version_, other->decred_script_version_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TxAck_TransactionType_TxOutputBinType::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TxAck_TransactionType_TxOutputBinType_descriptor_;
  metadata.reflection = TxAck_TransactionType_TxOutputBinType_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

const ::google::protobuf::EnumDescriptor* TxAck_TransactionType_TxOutputType_OutputScriptType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TxAck_TransactionType_TxOutputType_OutputScriptType_descriptor_;
}
bool TxAck_TransactionType_TxOutputType_OutputScriptType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const TxAck_TransactionType_TxOutputType_OutputScriptType TxAck_TransactionType_TxOutputType::PAYTOADDRESS;
const TxAck_TransactionType_TxOutputType_OutputScriptType TxAck_TransactionType_TxOutputType::PAYTOSCRIPTHASH;
const TxAck_TransactionType_TxOutputType_OutputScriptType TxAck_TransactionType_TxOutputType::PAYTOMULTISIG;
const TxAck_TransactionType_TxOutputType_OutputScriptType TxAck_TransactionType_TxOutputType::PAYTOOPRETURN;
const TxAck_TransactionType_TxOutputType_OutputScriptType TxAck_TransactionType_TxOutputType::PAYTOWITNESS;
const TxAck_TransactionType_TxOutputType_OutputScriptType TxAck_TransactionType_TxOutputType::PAYTOP2SHWITNESS;
const TxAck_TransactionType_TxOutputType_OutputScriptType TxAck_TransactionType_TxOutputType::OutputScriptType_MIN;
const TxAck_TransactionType_TxOutputType_OutputScriptType TxAck_TransactionType_TxOutputType::OutputScriptType_MAX;
const int TxAck_TransactionType_TxOutputType::OutputScriptType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int TxAck_TransactionType_TxOutputType::kAddressFieldNumber;
const int TxAck_TransactionType_TxOutputType::kAddressNFieldNumber;
const int TxAck_TransactionType_TxOutputType::kAmountFieldNumber;
const int TxAck_TransactionType_TxOutputType::kScriptTypeFieldNumber;
const int TxAck_TransactionType_TxOutputType::kMultisigFieldNumber;
const int TxAck_TransactionType_TxOutputType::kOpReturnDataFieldNumber;
const int TxAck_TransactionType_TxOutputType::kDecredScriptVersionFieldNumber;
const int TxAck_TransactionType_TxOutputType::kBlockHashBip115FieldNumber;
const int TxAck_TransactionType_TxOutputType::kBlockHeightBip115FieldNumber;
#endif  // !_MSC_VER

TxAck_TransactionType_TxOutputType::TxAck_TransactionType_TxOutputType()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:TxAck.TransactionType.TxOutputType)
}

void TxAck_TransactionType_TxOutputType::InitAsDefaultInstance() {
  multisig_ = const_cast< ::MultisigRedeemScriptType*>(&::MultisigRedeemScriptType::default_instance());
}

TxAck_TransactionType_TxOutputType::TxAck_TransactionType_TxOutputType(const TxAck_TransactionType_TxOutputType& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:TxAck.TransactionType.TxOutputType)
}

void TxAck_TransactionType_TxOutputType::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  amount_ = GOOGLE_ULONGLONG(0);
  script_type_ = 0;
  multisig_ = NULL;
  op_return_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  decred_script_version_ = 0u;
  block_hash_bip115_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  block_height_bip115_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TxAck_TransactionType_TxOutputType::~TxAck_TransactionType_TxOutputType() {
  // @@protoc_insertion_point(destructor:TxAck.TransactionType.TxOutputType)
  SharedDtor();
}

void TxAck_TransactionType_TxOutputType::SharedDtor() {
  if (address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete address_;
  }
  if (op_return_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete op_return_data_;
  }
  if (block_hash_bip115_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete block_hash_bip115_;
  }
  if (this != default_instance_) {
    delete multisig_;
  }
}

void TxAck_TransactionType_TxOutputType::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TxAck_TransactionType_TxOutputType::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TxAck_TransactionType_TxOutputType_descriptor_;
}

const TxAck_TransactionType_TxOutputType& TxAck_TransactionType_TxOutputType::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2dbitcoin_2eproto();
  return *default_instance_;
}

TxAck_TransactionType_TxOutputType* TxAck_TransactionType_TxOutputType::default_instance_ = NULL;

TxAck_TransactionType_TxOutputType* TxAck_TransactionType_TxOutputType::New() const {
  return new TxAck_TransactionType_TxOutputType;
}

void TxAck_TransactionType_TxOutputType::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<TxAck_TransactionType_TxOutputType*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 253) {
    ZR_(script_type_, decred_script_version_);
    if (has_address()) {
      if (address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        address_->clear();
      }
    }
    amount_ = GOOGLE_ULONGLONG(0);
    if (has_multisig()) {
      if (multisig_ != NULL) multisig_->::MultisigRedeemScriptType::Clear();
    }
    if (has_op_return_data()) {
      if (op_return_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        op_return_data_->clear();
      }
    }
    if (has_block_hash_bip115()) {
      if (block_hash_bip115_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        block_hash_bip115_->clear();
      }
    }
  }
  block_height_bip115_ = 0u;

#undef OFFSET_OF_FIELD_
#undef ZR_

  address_n_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TxAck_TransactionType_TxOutputType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TxAck.TransactionType.TxOutputType)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string address = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_address()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->address().data(), this->address().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "address");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_address_n;
        break;
      }

      // repeated uint32 address_n = 2;
      case 2: {
        if (tag == 16) {
         parse_address_n:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 16, input, this->mutable_address_n())));
        } else if (tag == 18) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_address_n())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_address_n;
        if (input->ExpectTag(24)) goto parse_amount;
        break;
      }

      // required uint64 amount = 3;
      case 3: {
        if (tag == 24) {
         parse_amount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &amount_)));
          set_has_amount();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_script_type;
        break;
      }

      // required .TxAck.TransactionType.TxOutputType.OutputScriptType script_type = 4;
      case 4: {
        if (tag == 32) {
         parse_script_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::TxAck_TransactionType_TxOutputType_OutputScriptType_IsValid(value)) {
            set_script_type(static_cast< ::TxAck_TransactionType_TxOutputType_OutputScriptType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(4, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_multisig;
        break;
      }

      // optional .MultisigRedeemScriptType multisig = 5;
      case 5: {
        if (tag == 42) {
         parse_multisig:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_multisig()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_op_return_data;
        break;
      }

      // optional bytes op_return_data = 6;
      case 6: {
        if (tag == 50) {
         parse_op_return_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_op_return_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_decred_script_version;
        break;
      }

      // optional uint32 decred_script_version = 7;
      case 7: {
        if (tag == 56) {
         parse_decred_script_version:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &decred_script_version_)));
          set_has_decred_script_version();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_block_hash_bip115;
        break;
      }

      // optional bytes block_hash_bip115 = 8;
      case 8: {
        if (tag == 66) {
         parse_block_hash_bip115:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_block_hash_bip115()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_block_height_bip115;
        break;
      }

      // optional uint32 block_height_bip115 = 9;
      case 9: {
        if (tag == 72) {
         parse_block_height_bip115:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &block_height_bip115_)));
          set_has_block_height_bip115();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TxAck.TransactionType.TxOutputType)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TxAck.TransactionType.TxOutputType)
  return false;
#undef DO_
}

void TxAck_TransactionType_TxOutputType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TxAck.TransactionType.TxOutputType)
  // optional string address = 1;
  if (has_address()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->address().data(), this->address().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "address");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->address(), output);
  }

  // repeated uint32 address_n = 2;
  for (int i = 0; i < this->address_n_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      2, this->address_n(i), output);
  }

  // required uint64 amount = 3;
  if (has_amount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->amount(), output);
  }

  // required .TxAck.TransactionType.TxOutputType.OutputScriptType script_type = 4;
  if (has_script_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->script_type(), output);
  }

  // optional .MultisigRedeemScriptType multisig = 5;
  if (has_multisig()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->multisig(), output);
  }

  // optional bytes op_return_data = 6;
  if (has_op_return_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      6, this->op_return_data(), output);
  }

  // optional uint32 decred_script_version = 7;
  if (has_decred_script_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->decred_script_version(), output);
  }

  // optional bytes block_hash_bip115 = 8;
  if (has_block_hash_bip115()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      8, this->block_hash_bip115(), output);
  }

  // optional uint32 block_height_bip115 = 9;
  if (has_block_height_bip115()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->block_height_bip115(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TxAck.TransactionType.TxOutputType)
}

::google::protobuf::uint8* TxAck_TransactionType_TxOutputType::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TxAck.TransactionType.TxOutputType)
  // optional string address = 1;
  if (has_address()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->address().data(), this->address().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "address");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->address(), target);
  }

  // repeated uint32 address_n = 2;
  for (int i = 0; i < this->address_n_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(2, this->address_n(i), target);
  }

  // required uint64 amount = 3;
  if (has_amount()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->amount(), target);
  }

  // required .TxAck.TransactionType.TxOutputType.OutputScriptType script_type = 4;
  if (has_script_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->script_type(), target);
  }

  // optional .MultisigRedeemScriptType multisig = 5;
  if (has_multisig()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->multisig(), target);
  }

  // optional bytes op_return_data = 6;
  if (has_op_return_data()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        6, this->op_return_data(), target);
  }

  // optional uint32 decred_script_version = 7;
  if (has_decred_script_version()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->decred_script_version(), target);
  }

  // optional bytes block_hash_bip115 = 8;
  if (has_block_hash_bip115()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        8, this->block_hash_bip115(), target);
  }

  // optional uint32 block_height_bip115 = 9;
  if (has_block_height_bip115()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(9, this->block_height_bip115(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TxAck.TransactionType.TxOutputType)
  return target;
}

int TxAck_TransactionType_TxOutputType::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string address = 1;
    if (has_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->address());
    }

    // required uint64 amount = 3;
    if (has_amount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->amount());
    }

    // required .TxAck.TransactionType.TxOutputType.OutputScriptType script_type = 4;
    if (has_script_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->script_type());
    }

    // optional .MultisigRedeemScriptType multisig = 5;
    if (has_multisig()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->multisig());
    }

    // optional bytes op_return_data = 6;
    if (has_op_return_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->op_return_data());
    }

    // optional uint32 decred_script_version = 7;
    if (has_decred_script_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->decred_script_version());
    }

    // optional bytes block_hash_bip115 = 8;
    if (has_block_hash_bip115()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->block_hash_bip115());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional uint32 block_height_bip115 = 9;
    if (has_block_height_bip115()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->block_height_bip115());
    }

  }
  // repeated uint32 address_n = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->address_n_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->address_n(i));
    }
    total_size += 1 * this->address_n_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TxAck_TransactionType_TxOutputType::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TxAck_TransactionType_TxOutputType* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TxAck_TransactionType_TxOutputType*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TxAck_TransactionType_TxOutputType::MergeFrom(const TxAck_TransactionType_TxOutputType& from) {
  GOOGLE_CHECK_NE(&from, this);
  address_n_.MergeFrom(from.address_n_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_address()) {
      set_address(from.address());
    }
    if (from.has_amount()) {
      set_amount(from.amount());
    }
    if (from.has_script_type()) {
      set_script_type(from.script_type());
    }
    if (from.has_multisig()) {
      mutable_multisig()->::MultisigRedeemScriptType::MergeFrom(from.multisig());
    }
    if (from.has_op_return_data()) {
      set_op_return_data(from.op_return_data());
    }
    if (from.has_decred_script_version()) {
      set_decred_script_version(from.decred_script_version());
    }
    if (from.has_block_hash_bip115()) {
      set_block_hash_bip115(from.block_hash_bip115());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_block_height_bip115()) {
      set_block_height_bip115(from.block_height_bip115());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TxAck_TransactionType_TxOutputType::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TxAck_TransactionType_TxOutputType::CopyFrom(const TxAck_TransactionType_TxOutputType& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TxAck_TransactionType_TxOutputType::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000c) != 0x0000000c) return false;

  if (has_multisig()) {
    if (!this->multisig().IsInitialized()) return false;
  }
  return true;
}

void TxAck_TransactionType_TxOutputType::Swap(TxAck_TransactionType_TxOutputType* other) {
  if (other != this) {
    std::swap(address_, other->address_);
    address_n_.Swap(&other->address_n_);
    std::swap(amount_, other->amount_);
    std::swap(script_type_, other->script_type_);
    std::swap(multisig_, other->multisig_);
    std::swap(op_return_data_, other->op_return_data_);
    std::swap(decred_script_version_, other->decred_script_version_);
    std::swap(block_hash_bip115_, other->block_hash_bip115_);
    std::swap(block_height_bip115_, other->block_height_bip115_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TxAck_TransactionType_TxOutputType::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TxAck_TransactionType_TxOutputType_descriptor_;
  metadata.reflection = TxAck_TransactionType_TxOutputType_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int TxAck_TransactionType::kVersionFieldNumber;
const int TxAck_TransactionType::kInputsFieldNumber;
const int TxAck_TransactionType::kBinOutputsFieldNumber;
const int TxAck_TransactionType::kLockTimeFieldNumber;
const int TxAck_TransactionType::kOutputsFieldNumber;
const int TxAck_TransactionType::kInputsCntFieldNumber;
const int TxAck_TransactionType::kOutputsCntFieldNumber;
const int TxAck_TransactionType::kExtraDataFieldNumber;
const int TxAck_TransactionType::kExtraDataLenFieldNumber;
const int TxAck_TransactionType::kExpiryFieldNumber;
const int TxAck_TransactionType::kOverwinteredFieldNumber;
#endif  // !_MSC_VER

TxAck_TransactionType::TxAck_TransactionType()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:TxAck.TransactionType)
}

void TxAck_TransactionType::InitAsDefaultInstance() {
}

TxAck_TransactionType::TxAck_TransactionType(const TxAck_TransactionType& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:TxAck.TransactionType)
}

void TxAck_TransactionType::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  version_ = 0u;
  lock_time_ = 0u;
  inputs_cnt_ = 0u;
  outputs_cnt_ = 0u;
  extra_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  extra_data_len_ = 0u;
  expiry_ = 0u;
  overwintered_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TxAck_TransactionType::~TxAck_TransactionType() {
  // @@protoc_insertion_point(destructor:TxAck.TransactionType)
  SharedDtor();
}

void TxAck_TransactionType::SharedDtor() {
  if (extra_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete extra_data_;
  }
  if (this != default_instance_) {
  }
}

void TxAck_TransactionType::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TxAck_TransactionType::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TxAck_TransactionType_descriptor_;
}

const TxAck_TransactionType& TxAck_TransactionType::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2dbitcoin_2eproto();
  return *default_instance_;
}

TxAck_TransactionType* TxAck_TransactionType::default_instance_ = NULL;

TxAck_TransactionType* TxAck_TransactionType::New() const {
  return new TxAck_TransactionType;
}

void TxAck_TransactionType::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<TxAck_TransactionType*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 233) {
    ZR_(version_, lock_time_);
    ZR_(inputs_cnt_, outputs_cnt_);
    if (has_extra_data()) {
      if (extra_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        extra_data_->clear();
      }
    }
  }
  ZR_(extra_data_len_, overwintered_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  inputs_.Clear();
  bin_outputs_.Clear();
  outputs_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TxAck_TransactionType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TxAck.TransactionType)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 version = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &version_)));
          set_has_version();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_inputs;
        break;
      }

      // repeated .TxAck.TransactionType.TxInputType inputs = 2;
      case 2: {
        if (tag == 18) {
         parse_inputs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_inputs()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_inputs;
        if (input->ExpectTag(26)) goto parse_bin_outputs;
        break;
      }

      // repeated .TxAck.TransactionType.TxOutputBinType bin_outputs = 3;
      case 3: {
        if (tag == 26) {
         parse_bin_outputs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_bin_outputs()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_bin_outputs;
        if (input->ExpectTag(32)) goto parse_lock_time;
        break;
      }

      // optional uint32 lock_time = 4;
      case 4: {
        if (tag == 32) {
         parse_lock_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &lock_time_)));
          set_has_lock_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_outputs;
        break;
      }

      // repeated .TxAck.TransactionType.TxOutputType outputs = 5;
      case 5: {
        if (tag == 42) {
         parse_outputs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_outputs()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_outputs;
        if (input->ExpectTag(48)) goto parse_inputs_cnt;
        break;
      }

      // optional uint32 inputs_cnt = 6;
      case 6: {
        if (tag == 48) {
         parse_inputs_cnt:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &inputs_cnt_)));
          set_has_inputs_cnt();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_outputs_cnt;
        break;
      }

      // optional uint32 outputs_cnt = 7;
      case 7: {
        if (tag == 56) {
         parse_outputs_cnt:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &outputs_cnt_)));
          set_has_outputs_cnt();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_extra_data;
        break;
      }

      // optional bytes extra_data = 8;
      case 8: {
        if (tag == 66) {
         parse_extra_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_extra_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_extra_data_len;
        break;
      }

      // optional uint32 extra_data_len = 9;
      case 9: {
        if (tag == 72) {
         parse_extra_data_len:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &extra_data_len_)));
          set_has_extra_data_len();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_expiry;
        break;
      }

      // optional uint32 expiry = 10;
      case 10: {
        if (tag == 80) {
         parse_expiry:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &expiry_)));
          set_has_expiry();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_overwintered;
        break;
      }

      // optional bool overwintered = 11;
      case 11: {
        if (tag == 88) {
         parse_overwintered:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &overwintered_)));
          set_has_overwintered();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TxAck.TransactionType)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TxAck.TransactionType)
  return false;
#undef DO_
}

void TxAck_TransactionType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TxAck.TransactionType)
  // optional uint32 version = 1;
  if (has_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->version(), output);
  }

  // repeated .TxAck.TransactionType.TxInputType inputs = 2;
  for (int i = 0; i < this->inputs_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->inputs(i), output);
  }

  // repeated .TxAck.TransactionType.TxOutputBinType bin_outputs = 3;
  for (int i = 0; i < this->bin_outputs_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->bin_outputs(i), output);
  }

  // optional uint32 lock_time = 4;
  if (has_lock_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->lock_time(), output);
  }

  // repeated .TxAck.TransactionType.TxOutputType outputs = 5;
  for (int i = 0; i < this->outputs_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->outputs(i), output);
  }

  // optional uint32 inputs_cnt = 6;
  if (has_inputs_cnt()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->inputs_cnt(), output);
  }

  // optional uint32 outputs_cnt = 7;
  if (has_outputs_cnt()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->outputs_cnt(), output);
  }

  // optional bytes extra_data = 8;
  if (has_extra_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      8, this->extra_data(), output);
  }

  // optional uint32 extra_data_len = 9;
  if (has_extra_data_len()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->extra_data_len(), output);
  }

  // optional uint32 expiry = 10;
  if (has_expiry()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->expiry(), output);
  }

  // optional bool overwintered = 11;
  if (has_overwintered()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(11, this->overwintered(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TxAck.TransactionType)
}

::google::protobuf::uint8* TxAck_TransactionType::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TxAck.TransactionType)
  // optional uint32 version = 1;
  if (has_version()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->version(), target);
  }

  // repeated .TxAck.TransactionType.TxInputType inputs = 2;
  for (int i = 0; i < this->inputs_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->inputs(i), target);
  }

  // repeated .TxAck.TransactionType.TxOutputBinType bin_outputs = 3;
  for (int i = 0; i < this->bin_outputs_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->bin_outputs(i), target);
  }

  // optional uint32 lock_time = 4;
  if (has_lock_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->lock_time(), target);
  }

  // repeated .TxAck.TransactionType.TxOutputType outputs = 5;
  for (int i = 0; i < this->outputs_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->outputs(i), target);
  }

  // optional uint32 inputs_cnt = 6;
  if (has_inputs_cnt()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->inputs_cnt(), target);
  }

  // optional uint32 outputs_cnt = 7;
  if (has_outputs_cnt()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->outputs_cnt(), target);
  }

  // optional bytes extra_data = 8;
  if (has_extra_data()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        8, this->extra_data(), target);
  }

  // optional uint32 extra_data_len = 9;
  if (has_extra_data_len()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(9, this->extra_data_len(), target);
  }

  // optional uint32 expiry = 10;
  if (has_expiry()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(10, this->expiry(), target);
  }

  // optional bool overwintered = 11;
  if (has_overwintered()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(11, this->overwintered(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TxAck.TransactionType)
  return target;
}

int TxAck_TransactionType::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 version = 1;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->version());
    }

    // optional uint32 lock_time = 4;
    if (has_lock_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->lock_time());
    }

    // optional uint32 inputs_cnt = 6;
    if (has_inputs_cnt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->inputs_cnt());
    }

    // optional uint32 outputs_cnt = 7;
    if (has_outputs_cnt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->outputs_cnt());
    }

    // optional bytes extra_data = 8;
    if (has_extra_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->extra_data());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional uint32 extra_data_len = 9;
    if (has_extra_data_len()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->extra_data_len());
    }

    // optional uint32 expiry = 10;
    if (has_expiry()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->expiry());
    }

    // optional bool overwintered = 11;
    if (has_overwintered()) {
      total_size += 1 + 1;
    }

  }
  // repeated .TxAck.TransactionType.TxInputType inputs = 2;
  total_size += 1 * this->inputs_size();
  for (int i = 0; i < this->inputs_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->inputs(i));
  }

  // repeated .TxAck.TransactionType.TxOutputBinType bin_outputs = 3;
  total_size += 1 * this->bin_outputs_size();
  for (int i = 0; i < this->bin_outputs_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->bin_outputs(i));
  }

  // repeated .TxAck.TransactionType.TxOutputType outputs = 5;
  total_size += 1 * this->outputs_size();
  for (int i = 0; i < this->outputs_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->outputs(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TxAck_TransactionType::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TxAck_TransactionType* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TxAck_TransactionType*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TxAck_TransactionType::MergeFrom(const TxAck_TransactionType& from) {
  GOOGLE_CHECK_NE(&from, this);
  inputs_.MergeFrom(from.inputs_);
  bin_outputs_.MergeFrom(from.bin_outputs_);
  outputs_.MergeFrom(from.outputs_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_lock_time()) {
      set_lock_time(from.lock_time());
    }
    if (from.has_inputs_cnt()) {
      set_inputs_cnt(from.inputs_cnt());
    }
    if (from.has_outputs_cnt()) {
      set_outputs_cnt(from.outputs_cnt());
    }
    if (from.has_extra_data()) {
      set_extra_data(from.extra_data());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_extra_data_len()) {
      set_extra_data_len(from.extra_data_len());
    }
    if (from.has_expiry()) {
      set_expiry(from.expiry());
    }
    if (from.has_overwintered()) {
      set_overwintered(from.overwintered());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TxAck_TransactionType::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TxAck_TransactionType::CopyFrom(const TxAck_TransactionType& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TxAck_TransactionType::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->inputs())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->bin_outputs())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->outputs())) return false;
  return true;
}

void TxAck_TransactionType::Swap(TxAck_TransactionType* other) {
  if (other != this) {
    std::swap(version_, other->version_);
    inputs_.Swap(&other->inputs_);
    bin_outputs_.Swap(&other->bin_outputs_);
    std::swap(lock_time_, other->lock_time_);
    outputs_.Swap(&other->outputs_);
    std::swap(inputs_cnt_, other->inputs_cnt_);
    std::swap(outputs_cnt_, other->outputs_cnt_);
    std::swap(extra_data_, other->extra_data_);
    std::swap(extra_data_len_, other->extra_data_len_);
    std::swap(expiry_, other->expiry_);
    std::swap(overwintered_, other->overwintered_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TxAck_TransactionType::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TxAck_TransactionType_descriptor_;
  metadata.reflection = TxAck_TransactionType_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int TxAck::kTxFieldNumber;
#endif  // !_MSC_VER

TxAck::TxAck()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:TxAck)
}

void TxAck::InitAsDefaultInstance() {
  tx_ = const_cast< ::TxAck_TransactionType*>(&::TxAck_TransactionType::default_instance());
}

TxAck::TxAck(const TxAck& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:TxAck)
}

void TxAck::SharedCtor() {
  _cached_size_ = 0;
  tx_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TxAck::~TxAck() {
  // @@protoc_insertion_point(destructor:TxAck)
  SharedDtor();
}

void TxAck::SharedDtor() {
  if (this != default_instance_) {
    delete tx_;
  }
}

void TxAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TxAck::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TxAck_descriptor_;
}

const TxAck& TxAck::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2dbitcoin_2eproto();
  return *default_instance_;
}

TxAck* TxAck::default_instance_ = NULL;

TxAck* TxAck::New() const {
  return new TxAck;
}

void TxAck::Clear() {
  if (has_tx()) {
    if (tx_ != NULL) tx_->::TxAck_TransactionType::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TxAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TxAck)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .TxAck.TransactionType tx = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_tx()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TxAck)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TxAck)
  return false;
#undef DO_
}

void TxAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TxAck)
  // optional .TxAck.TransactionType tx = 1;
  if (has_tx()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->tx(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TxAck)
}

::google::protobuf::uint8* TxAck::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TxAck)
  // optional .TxAck.TransactionType tx = 1;
  if (has_tx()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->tx(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TxAck)
  return target;
}

int TxAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .TxAck.TransactionType tx = 1;
    if (has_tx()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->tx());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TxAck::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TxAck* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TxAck*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TxAck::MergeFrom(const TxAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_tx()) {
      mutable_tx()->::TxAck_TransactionType::MergeFrom(from.tx());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TxAck::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TxAck::CopyFrom(const TxAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TxAck::IsInitialized() const {

  if (has_tx()) {
    if (!this->tx().IsInitialized()) return false;
  }
  return true;
}

void TxAck::Swap(TxAck* other) {
  if (other != this) {
    std::swap(tx_, other->tx_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TxAck::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TxAck_descriptor_;
  metadata.reflection = TxAck_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)
