// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages-bitcoin.proto

#ifndef PROTOBUF_messages_2dbitcoin_2eproto__INCLUDED
#define PROTOBUF_messages_2dbitcoin_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "messages-common.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_messages_2dbitcoin_2eproto();
void protobuf_AssignDesc_messages_2dbitcoin_2eproto();
void protobuf_ShutdownFile_messages_2dbitcoin_2eproto();

class MultisigRedeemScriptType;
class MultisigRedeemScriptType_HDNodePathType;
class GetPublicKey;
class PublicKey;
class GetAddress;
class Address;
class SignMessage;
class MessageSignature;
class VerifyMessage;
class SignTx;
class TxRequest;
class TxRequest_TxRequestDetailsType;
class TxRequest_TxRequestSerializedType;
class TxAck;
class TxAck_TransactionType;
class TxAck_TransactionType_TxInputType;
class TxAck_TransactionType_TxOutputBinType;
class TxAck_TransactionType_TxOutputType;

enum TxRequest_RequestType {
  TxRequest_RequestType_TXINPUT = 0,
  TxRequest_RequestType_TXOUTPUT = 1,
  TxRequest_RequestType_TXMETA = 2,
  TxRequest_RequestType_TXFINISHED = 3,
  TxRequest_RequestType_TXEXTRADATA = 4
};
bool TxRequest_RequestType_IsValid(int value);
const TxRequest_RequestType TxRequest_RequestType_RequestType_MIN = TxRequest_RequestType_TXINPUT;
const TxRequest_RequestType TxRequest_RequestType_RequestType_MAX = TxRequest_RequestType_TXEXTRADATA;
const int TxRequest_RequestType_RequestType_ARRAYSIZE = TxRequest_RequestType_RequestType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TxRequest_RequestType_descriptor();
inline const ::std::string& TxRequest_RequestType_Name(TxRequest_RequestType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TxRequest_RequestType_descriptor(), value);
}
inline bool TxRequest_RequestType_Parse(
    const ::std::string& name, TxRequest_RequestType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TxRequest_RequestType>(
    TxRequest_RequestType_descriptor(), name, value);
}
enum TxAck_TransactionType_TxOutputType_OutputScriptType {
  TxAck_TransactionType_TxOutputType_OutputScriptType_PAYTOADDRESS = 0,
  TxAck_TransactionType_TxOutputType_OutputScriptType_PAYTOSCRIPTHASH = 1,
  TxAck_TransactionType_TxOutputType_OutputScriptType_PAYTOMULTISIG = 2,
  TxAck_TransactionType_TxOutputType_OutputScriptType_PAYTOOPRETURN = 3,
  TxAck_TransactionType_TxOutputType_OutputScriptType_PAYTOWITNESS = 4,
  TxAck_TransactionType_TxOutputType_OutputScriptType_PAYTOP2SHWITNESS = 5
};
bool TxAck_TransactionType_TxOutputType_OutputScriptType_IsValid(int value);
const TxAck_TransactionType_TxOutputType_OutputScriptType TxAck_TransactionType_TxOutputType_OutputScriptType_OutputScriptType_MIN = TxAck_TransactionType_TxOutputType_OutputScriptType_PAYTOADDRESS;
const TxAck_TransactionType_TxOutputType_OutputScriptType TxAck_TransactionType_TxOutputType_OutputScriptType_OutputScriptType_MAX = TxAck_TransactionType_TxOutputType_OutputScriptType_PAYTOP2SHWITNESS;
const int TxAck_TransactionType_TxOutputType_OutputScriptType_OutputScriptType_ARRAYSIZE = TxAck_TransactionType_TxOutputType_OutputScriptType_OutputScriptType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TxAck_TransactionType_TxOutputType_OutputScriptType_descriptor();
inline const ::std::string& TxAck_TransactionType_TxOutputType_OutputScriptType_Name(TxAck_TransactionType_TxOutputType_OutputScriptType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TxAck_TransactionType_TxOutputType_OutputScriptType_descriptor(), value);
}
inline bool TxAck_TransactionType_TxOutputType_OutputScriptType_Parse(
    const ::std::string& name, TxAck_TransactionType_TxOutputType_OutputScriptType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TxAck_TransactionType_TxOutputType_OutputScriptType>(
    TxAck_TransactionType_TxOutputType_OutputScriptType_descriptor(), name, value);
}
enum InputScriptType {
  SPENDADDRESS = 0,
  SPENDMULTISIG = 1,
  EXTERNAL = 2,
  SPENDWITNESS = 3,
  SPENDP2SHWITNESS = 4
};
bool InputScriptType_IsValid(int value);
const InputScriptType InputScriptType_MIN = SPENDADDRESS;
const InputScriptType InputScriptType_MAX = SPENDP2SHWITNESS;
const int InputScriptType_ARRAYSIZE = InputScriptType_MAX + 1;

const ::google::protobuf::EnumDescriptor* InputScriptType_descriptor();
inline const ::std::string& InputScriptType_Name(InputScriptType value) {
  return ::google::protobuf::internal::NameOfEnum(
    InputScriptType_descriptor(), value);
}
inline bool InputScriptType_Parse(
    const ::std::string& name, InputScriptType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<InputScriptType>(
    InputScriptType_descriptor(), name, value);
}
// ===================================================================

class MultisigRedeemScriptType_HDNodePathType : public ::google::protobuf::Message {
 public:
  MultisigRedeemScriptType_HDNodePathType();
  virtual ~MultisigRedeemScriptType_HDNodePathType();

  MultisigRedeemScriptType_HDNodePathType(const MultisigRedeemScriptType_HDNodePathType& from);

  inline MultisigRedeemScriptType_HDNodePathType& operator=(const MultisigRedeemScriptType_HDNodePathType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MultisigRedeemScriptType_HDNodePathType& default_instance();

  void Swap(MultisigRedeemScriptType_HDNodePathType* other);

  // implements Message ----------------------------------------------

  MultisigRedeemScriptType_HDNodePathType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MultisigRedeemScriptType_HDNodePathType& from);
  void MergeFrom(const MultisigRedeemScriptType_HDNodePathType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .HDNodeType node = 1;
  inline bool has_node() const;
  inline void clear_node();
  static const int kNodeFieldNumber = 1;
  inline const ::HDNodeType& node() const;
  inline ::HDNodeType* mutable_node();
  inline ::HDNodeType* release_node();
  inline void set_allocated_node(::HDNodeType* node);

  // repeated uint32 address_n = 2;
  inline int address_n_size() const;
  inline void clear_address_n();
  static const int kAddressNFieldNumber = 2;
  inline ::google::protobuf::uint32 address_n(int index) const;
  inline void set_address_n(int index, ::google::protobuf::uint32 value);
  inline void add_address_n(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // @@protoc_insertion_point(class_scope:MultisigRedeemScriptType.HDNodePathType)
 private:
  inline void set_has_node();
  inline void clear_has_node();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::HDNodeType* node_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  friend void  protobuf_AddDesc_messages_2dbitcoin_2eproto();
  friend void protobuf_AssignDesc_messages_2dbitcoin_2eproto();
  friend void protobuf_ShutdownFile_messages_2dbitcoin_2eproto();

  void InitAsDefaultInstance();
  static MultisigRedeemScriptType_HDNodePathType* default_instance_;
};
// -------------------------------------------------------------------

class MultisigRedeemScriptType : public ::google::protobuf::Message {
 public:
  MultisigRedeemScriptType();
  virtual ~MultisigRedeemScriptType();

  MultisigRedeemScriptType(const MultisigRedeemScriptType& from);

  inline MultisigRedeemScriptType& operator=(const MultisigRedeemScriptType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MultisigRedeemScriptType& default_instance();

  void Swap(MultisigRedeemScriptType* other);

  // implements Message ----------------------------------------------

  MultisigRedeemScriptType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MultisigRedeemScriptType& from);
  void MergeFrom(const MultisigRedeemScriptType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MultisigRedeemScriptType_HDNodePathType HDNodePathType;

  // accessors -------------------------------------------------------

  // repeated .MultisigRedeemScriptType.HDNodePathType pubkeys = 1;
  inline int pubkeys_size() const;
  inline void clear_pubkeys();
  static const int kPubkeysFieldNumber = 1;
  inline const ::MultisigRedeemScriptType_HDNodePathType& pubkeys(int index) const;
  inline ::MultisigRedeemScriptType_HDNodePathType* mutable_pubkeys(int index);
  inline ::MultisigRedeemScriptType_HDNodePathType* add_pubkeys();
  inline const ::google::protobuf::RepeatedPtrField< ::MultisigRedeemScriptType_HDNodePathType >&
      pubkeys() const;
  inline ::google::protobuf::RepeatedPtrField< ::MultisigRedeemScriptType_HDNodePathType >*
      mutable_pubkeys();

  // repeated bytes signatures = 2;
  inline int signatures_size() const;
  inline void clear_signatures();
  static const int kSignaturesFieldNumber = 2;
  inline const ::std::string& signatures(int index) const;
  inline ::std::string* mutable_signatures(int index);
  inline void set_signatures(int index, const ::std::string& value);
  inline void set_signatures(int index, const char* value);
  inline void set_signatures(int index, const void* value, size_t size);
  inline ::std::string* add_signatures();
  inline void add_signatures(const ::std::string& value);
  inline void add_signatures(const char* value);
  inline void add_signatures(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& signatures() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_signatures();

  // optional uint32 m = 3;
  inline bool has_m() const;
  inline void clear_m();
  static const int kMFieldNumber = 3;
  inline ::google::protobuf::uint32 m() const;
  inline void set_m(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MultisigRedeemScriptType)
 private:
  inline void set_has_m();
  inline void clear_has_m();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::MultisigRedeemScriptType_HDNodePathType > pubkeys_;
  ::google::protobuf::RepeatedPtrField< ::std::string> signatures_;
  ::google::protobuf::uint32 m_;
  friend void  protobuf_AddDesc_messages_2dbitcoin_2eproto();
  friend void protobuf_AssignDesc_messages_2dbitcoin_2eproto();
  friend void protobuf_ShutdownFile_messages_2dbitcoin_2eproto();

  void InitAsDefaultInstance();
  static MultisigRedeemScriptType* default_instance_;
};
// -------------------------------------------------------------------

class GetPublicKey : public ::google::protobuf::Message {
 public:
  GetPublicKey();
  virtual ~GetPublicKey();

  GetPublicKey(const GetPublicKey& from);

  inline GetPublicKey& operator=(const GetPublicKey& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetPublicKey& default_instance();

  void Swap(GetPublicKey* other);

  // implements Message ----------------------------------------------

  GetPublicKey* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetPublicKey& from);
  void MergeFrom(const GetPublicKey& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 1;
  inline int address_n_size() const;
  inline void clear_address_n();
  static const int kAddressNFieldNumber = 1;
  inline ::google::protobuf::uint32 address_n(int index) const;
  inline void set_address_n(int index, ::google::protobuf::uint32 value);
  inline void add_address_n(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // optional string ecdsa_curve_name = 2;
  inline bool has_ecdsa_curve_name() const;
  inline void clear_ecdsa_curve_name();
  static const int kEcdsaCurveNameFieldNumber = 2;
  inline const ::std::string& ecdsa_curve_name() const;
  inline void set_ecdsa_curve_name(const ::std::string& value);
  inline void set_ecdsa_curve_name(const char* value);
  inline void set_ecdsa_curve_name(const char* value, size_t size);
  inline ::std::string* mutable_ecdsa_curve_name();
  inline ::std::string* release_ecdsa_curve_name();
  inline void set_allocated_ecdsa_curve_name(::std::string* ecdsa_curve_name);

  // optional bool show_display = 3;
  inline bool has_show_display() const;
  inline void clear_show_display();
  static const int kShowDisplayFieldNumber = 3;
  inline bool show_display() const;
  inline void set_show_display(bool value);

  // optional string coin_name = 4 [default = "Bitcoin"];
  inline bool has_coin_name() const;
  inline void clear_coin_name();
  static const int kCoinNameFieldNumber = 4;
  inline const ::std::string& coin_name() const;
  inline void set_coin_name(const ::std::string& value);
  inline void set_coin_name(const char* value);
  inline void set_coin_name(const char* value, size_t size);
  inline ::std::string* mutable_coin_name();
  inline ::std::string* release_coin_name();
  inline void set_allocated_coin_name(::std::string* coin_name);

  // @@protoc_insertion_point(class_scope:GetPublicKey)
 private:
  inline void set_has_ecdsa_curve_name();
  inline void clear_has_ecdsa_curve_name();
  inline void set_has_show_display();
  inline void clear_has_show_display();
  inline void set_has_coin_name();
  inline void clear_has_coin_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  ::std::string* ecdsa_curve_name_;
  static ::std::string* _default_coin_name_;
  ::std::string* coin_name_;
  bool show_display_;
  friend void  protobuf_AddDesc_messages_2dbitcoin_2eproto();
  friend void protobuf_AssignDesc_messages_2dbitcoin_2eproto();
  friend void protobuf_ShutdownFile_messages_2dbitcoin_2eproto();

  void InitAsDefaultInstance();
  static GetPublicKey* default_instance_;
};
// -------------------------------------------------------------------

class PublicKey : public ::google::protobuf::Message {
 public:
  PublicKey();
  virtual ~PublicKey();

  PublicKey(const PublicKey& from);

  inline PublicKey& operator=(const PublicKey& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PublicKey& default_instance();

  void Swap(PublicKey* other);

  // implements Message ----------------------------------------------

  PublicKey* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PublicKey& from);
  void MergeFrom(const PublicKey& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .HDNodeType node = 1;
  inline bool has_node() const;
  inline void clear_node();
  static const int kNodeFieldNumber = 1;
  inline const ::HDNodeType& node() const;
  inline ::HDNodeType* mutable_node();
  inline ::HDNodeType* release_node();
  inline void set_allocated_node(::HDNodeType* node);

  // optional string xpub = 2;
  inline bool has_xpub() const;
  inline void clear_xpub();
  static const int kXpubFieldNumber = 2;
  inline const ::std::string& xpub() const;
  inline void set_xpub(const ::std::string& value);
  inline void set_xpub(const char* value);
  inline void set_xpub(const char* value, size_t size);
  inline ::std::string* mutable_xpub();
  inline ::std::string* release_xpub();
  inline void set_allocated_xpub(::std::string* xpub);

  // @@protoc_insertion_point(class_scope:PublicKey)
 private:
  inline void set_has_node();
  inline void clear_has_node();
  inline void set_has_xpub();
  inline void clear_has_xpub();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::HDNodeType* node_;
  ::std::string* xpub_;
  friend void  protobuf_AddDesc_messages_2dbitcoin_2eproto();
  friend void protobuf_AssignDesc_messages_2dbitcoin_2eproto();
  friend void protobuf_ShutdownFile_messages_2dbitcoin_2eproto();

  void InitAsDefaultInstance();
  static PublicKey* default_instance_;
};
// -------------------------------------------------------------------

class GetAddress : public ::google::protobuf::Message {
 public:
  GetAddress();
  virtual ~GetAddress();

  GetAddress(const GetAddress& from);

  inline GetAddress& operator=(const GetAddress& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetAddress& default_instance();

  void Swap(GetAddress* other);

  // implements Message ----------------------------------------------

  GetAddress* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetAddress& from);
  void MergeFrom(const GetAddress& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 1;
  inline int address_n_size() const;
  inline void clear_address_n();
  static const int kAddressNFieldNumber = 1;
  inline ::google::protobuf::uint32 address_n(int index) const;
  inline void set_address_n(int index, ::google::protobuf::uint32 value);
  inline void add_address_n(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // optional string coin_name = 2 [default = "Bitcoin"];
  inline bool has_coin_name() const;
  inline void clear_coin_name();
  static const int kCoinNameFieldNumber = 2;
  inline const ::std::string& coin_name() const;
  inline void set_coin_name(const ::std::string& value);
  inline void set_coin_name(const char* value);
  inline void set_coin_name(const char* value, size_t size);
  inline ::std::string* mutable_coin_name();
  inline ::std::string* release_coin_name();
  inline void set_allocated_coin_name(::std::string* coin_name);

  // optional bool show_display = 3;
  inline bool has_show_display() const;
  inline void clear_show_display();
  static const int kShowDisplayFieldNumber = 3;
  inline bool show_display() const;
  inline void set_show_display(bool value);

  // optional .MultisigRedeemScriptType multisig = 4;
  inline bool has_multisig() const;
  inline void clear_multisig();
  static const int kMultisigFieldNumber = 4;
  inline const ::MultisigRedeemScriptType& multisig() const;
  inline ::MultisigRedeemScriptType* mutable_multisig();
  inline ::MultisigRedeemScriptType* release_multisig();
  inline void set_allocated_multisig(::MultisigRedeemScriptType* multisig);

  // optional .InputScriptType script_type = 5 [default = SPENDADDRESS];
  inline bool has_script_type() const;
  inline void clear_script_type();
  static const int kScriptTypeFieldNumber = 5;
  inline ::InputScriptType script_type() const;
  inline void set_script_type(::InputScriptType value);

  // @@protoc_insertion_point(class_scope:GetAddress)
 private:
  inline void set_has_coin_name();
  inline void clear_has_coin_name();
  inline void set_has_show_display();
  inline void clear_has_show_display();
  inline void set_has_multisig();
  inline void clear_has_multisig();
  inline void set_has_script_type();
  inline void clear_has_script_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  static ::std::string* _default_coin_name_;
  ::std::string* coin_name_;
  ::MultisigRedeemScriptType* multisig_;
  bool show_display_;
  int script_type_;
  friend void  protobuf_AddDesc_messages_2dbitcoin_2eproto();
  friend void protobuf_AssignDesc_messages_2dbitcoin_2eproto();
  friend void protobuf_ShutdownFile_messages_2dbitcoin_2eproto();

  void InitAsDefaultInstance();
  static GetAddress* default_instance_;
};
// -------------------------------------------------------------------

class Address : public ::google::protobuf::Message {
 public:
  Address();
  virtual ~Address();

  Address(const Address& from);

  inline Address& operator=(const Address& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Address& default_instance();

  void Swap(Address* other);

  // implements Message ----------------------------------------------

  Address* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Address& from);
  void MergeFrom(const Address& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string address = 1;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 1;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const char* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  inline void set_allocated_address(::std::string* address);

  // @@protoc_insertion_point(class_scope:Address)
 private:
  inline void set_has_address();
  inline void clear_has_address();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* address_;
  friend void  protobuf_AddDesc_messages_2dbitcoin_2eproto();
  friend void protobuf_AssignDesc_messages_2dbitcoin_2eproto();
  friend void protobuf_ShutdownFile_messages_2dbitcoin_2eproto();

  void InitAsDefaultInstance();
  static Address* default_instance_;
};
// -------------------------------------------------------------------

class SignMessage : public ::google::protobuf::Message {
 public:
  SignMessage();
  virtual ~SignMessage();

  SignMessage(const SignMessage& from);

  inline SignMessage& operator=(const SignMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignMessage& default_instance();

  void Swap(SignMessage* other);

  // implements Message ----------------------------------------------

  SignMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SignMessage& from);
  void MergeFrom(const SignMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 1;
  inline int address_n_size() const;
  inline void clear_address_n();
  static const int kAddressNFieldNumber = 1;
  inline ::google::protobuf::uint32 address_n(int index) const;
  inline void set_address_n(int index, ::google::protobuf::uint32 value);
  inline void add_address_n(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // required bytes message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const void* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // optional string coin_name = 3 [default = "Bitcoin"];
  inline bool has_coin_name() const;
  inline void clear_coin_name();
  static const int kCoinNameFieldNumber = 3;
  inline const ::std::string& coin_name() const;
  inline void set_coin_name(const ::std::string& value);
  inline void set_coin_name(const char* value);
  inline void set_coin_name(const char* value, size_t size);
  inline ::std::string* mutable_coin_name();
  inline ::std::string* release_coin_name();
  inline void set_allocated_coin_name(::std::string* coin_name);

  // optional .InputScriptType script_type = 4 [default = SPENDADDRESS];
  inline bool has_script_type() const;
  inline void clear_script_type();
  static const int kScriptTypeFieldNumber = 4;
  inline ::InputScriptType script_type() const;
  inline void set_script_type(::InputScriptType value);

  // @@protoc_insertion_point(class_scope:SignMessage)
 private:
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_coin_name();
  inline void clear_has_coin_name();
  inline void set_has_script_type();
  inline void clear_has_script_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  ::std::string* message_;
  static ::std::string* _default_coin_name_;
  ::std::string* coin_name_;
  int script_type_;
  friend void  protobuf_AddDesc_messages_2dbitcoin_2eproto();
  friend void protobuf_AssignDesc_messages_2dbitcoin_2eproto();
  friend void protobuf_ShutdownFile_messages_2dbitcoin_2eproto();

  void InitAsDefaultInstance();
  static SignMessage* default_instance_;
};
// -------------------------------------------------------------------

class MessageSignature : public ::google::protobuf::Message {
 public:
  MessageSignature();
  virtual ~MessageSignature();

  MessageSignature(const MessageSignature& from);

  inline MessageSignature& operator=(const MessageSignature& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageSignature& default_instance();

  void Swap(MessageSignature* other);

  // implements Message ----------------------------------------------

  MessageSignature* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MessageSignature& from);
  void MergeFrom(const MessageSignature& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string address = 1;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 1;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const char* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  inline void set_allocated_address(::std::string* address);

  // optional bytes signature = 2;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 2;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const void* value, size_t size);
  inline ::std::string* mutable_signature();
  inline ::std::string* release_signature();
  inline void set_allocated_signature(::std::string* signature);

  // @@protoc_insertion_point(class_scope:MessageSignature)
 private:
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_signature();
  inline void clear_has_signature();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* address_;
  ::std::string* signature_;
  friend void  protobuf_AddDesc_messages_2dbitcoin_2eproto();
  friend void protobuf_AssignDesc_messages_2dbitcoin_2eproto();
  friend void protobuf_ShutdownFile_messages_2dbitcoin_2eproto();

  void InitAsDefaultInstance();
  static MessageSignature* default_instance_;
};
// -------------------------------------------------------------------

class VerifyMessage : public ::google::protobuf::Message {
 public:
  VerifyMessage();
  virtual ~VerifyMessage();

  VerifyMessage(const VerifyMessage& from);

  inline VerifyMessage& operator=(const VerifyMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VerifyMessage& default_instance();

  void Swap(VerifyMessage* other);

  // implements Message ----------------------------------------------

  VerifyMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VerifyMessage& from);
  void MergeFrom(const VerifyMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string address = 1;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 1;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const char* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  inline void set_allocated_address(::std::string* address);

  // optional bytes signature = 2;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 2;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const void* value, size_t size);
  inline ::std::string* mutable_signature();
  inline ::std::string* release_signature();
  inline void set_allocated_signature(::std::string* signature);

  // optional bytes message = 3;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 3;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const void* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // optional string coin_name = 4 [default = "Bitcoin"];
  inline bool has_coin_name() const;
  inline void clear_coin_name();
  static const int kCoinNameFieldNumber = 4;
  inline const ::std::string& coin_name() const;
  inline void set_coin_name(const ::std::string& value);
  inline void set_coin_name(const char* value);
  inline void set_coin_name(const char* value, size_t size);
  inline ::std::string* mutable_coin_name();
  inline ::std::string* release_coin_name();
  inline void set_allocated_coin_name(::std::string* coin_name);

  // @@protoc_insertion_point(class_scope:VerifyMessage)
 private:
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_signature();
  inline void clear_has_signature();
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_coin_name();
  inline void clear_has_coin_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* address_;
  ::std::string* signature_;
  ::std::string* message_;
  static ::std::string* _default_coin_name_;
  ::std::string* coin_name_;
  friend void  protobuf_AddDesc_messages_2dbitcoin_2eproto();
  friend void protobuf_AssignDesc_messages_2dbitcoin_2eproto();
  friend void protobuf_ShutdownFile_messages_2dbitcoin_2eproto();

  void InitAsDefaultInstance();
  static VerifyMessage* default_instance_;
};
// -------------------------------------------------------------------

class SignTx : public ::google::protobuf::Message {
 public:
  SignTx();
  virtual ~SignTx();

  SignTx(const SignTx& from);

  inline SignTx& operator=(const SignTx& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignTx& default_instance();

  void Swap(SignTx* other);

  // implements Message ----------------------------------------------

  SignTx* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SignTx& from);
  void MergeFrom(const SignTx& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 outputs_count = 1;
  inline bool has_outputs_count() const;
  inline void clear_outputs_count();
  static const int kOutputsCountFieldNumber = 1;
  inline ::google::protobuf::uint32 outputs_count() const;
  inline void set_outputs_count(::google::protobuf::uint32 value);

  // required uint32 inputs_count = 2;
  inline bool has_inputs_count() const;
  inline void clear_inputs_count();
  static const int kInputsCountFieldNumber = 2;
  inline ::google::protobuf::uint32 inputs_count() const;
  inline void set_inputs_count(::google::protobuf::uint32 value);

  // optional string coin_name = 3 [default = "Bitcoin"];
  inline bool has_coin_name() const;
  inline void clear_coin_name();
  static const int kCoinNameFieldNumber = 3;
  inline const ::std::string& coin_name() const;
  inline void set_coin_name(const ::std::string& value);
  inline void set_coin_name(const char* value);
  inline void set_coin_name(const char* value, size_t size);
  inline ::std::string* mutable_coin_name();
  inline ::std::string* release_coin_name();
  inline void set_allocated_coin_name(::std::string* coin_name);

  // optional uint32 version = 4 [default = 1];
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 4;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);

  // optional uint32 lock_time = 5 [default = 0];
  inline bool has_lock_time() const;
  inline void clear_lock_time();
  static const int kLockTimeFieldNumber = 5;
  inline ::google::protobuf::uint32 lock_time() const;
  inline void set_lock_time(::google::protobuf::uint32 value);

  // optional uint32 expiry = 6;
  inline bool has_expiry() const;
  inline void clear_expiry();
  static const int kExpiryFieldNumber = 6;
  inline ::google::protobuf::uint32 expiry() const;
  inline void set_expiry(::google::protobuf::uint32 value);

  // optional bool overwintered = 7;
  inline bool has_overwintered() const;
  inline void clear_overwintered();
  static const int kOverwinteredFieldNumber = 7;
  inline bool overwintered() const;
  inline void set_overwintered(bool value);

  // @@protoc_insertion_point(class_scope:SignTx)
 private:
  inline void set_has_outputs_count();
  inline void clear_has_outputs_count();
  inline void set_has_inputs_count();
  inline void clear_has_inputs_count();
  inline void set_has_coin_name();
  inline void clear_has_coin_name();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_lock_time();
  inline void clear_has_lock_time();
  inline void set_has_expiry();
  inline void clear_has_expiry();
  inline void set_has_overwintered();
  inline void clear_has_overwintered();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 outputs_count_;
  ::google::protobuf::uint32 inputs_count_;
  static ::std::string* _default_coin_name_;
  ::std::string* coin_name_;
  ::google::protobuf::uint32 version_;
  ::google::protobuf::uint32 lock_time_;
  ::google::protobuf::uint32 expiry_;
  bool overwintered_;
  friend void  protobuf_AddDesc_messages_2dbitcoin_2eproto();
  friend void protobuf_AssignDesc_messages_2dbitcoin_2eproto();
  friend void protobuf_ShutdownFile_messages_2dbitcoin_2eproto();

  void InitAsDefaultInstance();
  static SignTx* default_instance_;
};
// -------------------------------------------------------------------

class TxRequest_TxRequestDetailsType : public ::google::protobuf::Message {
 public:
  TxRequest_TxRequestDetailsType();
  virtual ~TxRequest_TxRequestDetailsType();

  TxRequest_TxRequestDetailsType(const TxRequest_TxRequestDetailsType& from);

  inline TxRequest_TxRequestDetailsType& operator=(const TxRequest_TxRequestDetailsType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TxRequest_TxRequestDetailsType& default_instance();

  void Swap(TxRequest_TxRequestDetailsType* other);

  // implements Message ----------------------------------------------

  TxRequest_TxRequestDetailsType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TxRequest_TxRequestDetailsType& from);
  void MergeFrom(const TxRequest_TxRequestDetailsType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 request_index = 1;
  inline bool has_request_index() const;
  inline void clear_request_index();
  static const int kRequestIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 request_index() const;
  inline void set_request_index(::google::protobuf::uint32 value);

  // optional bytes tx_hash = 2;
  inline bool has_tx_hash() const;
  inline void clear_tx_hash();
  static const int kTxHashFieldNumber = 2;
  inline const ::std::string& tx_hash() const;
  inline void set_tx_hash(const ::std::string& value);
  inline void set_tx_hash(const char* value);
  inline void set_tx_hash(const void* value, size_t size);
  inline ::std::string* mutable_tx_hash();
  inline ::std::string* release_tx_hash();
  inline void set_allocated_tx_hash(::std::string* tx_hash);

  // optional uint32 extra_data_len = 3;
  inline bool has_extra_data_len() const;
  inline void clear_extra_data_len();
  static const int kExtraDataLenFieldNumber = 3;
  inline ::google::protobuf::uint32 extra_data_len() const;
  inline void set_extra_data_len(::google::protobuf::uint32 value);

  // optional uint32 extra_data_offset = 4;
  inline bool has_extra_data_offset() const;
  inline void clear_extra_data_offset();
  static const int kExtraDataOffsetFieldNumber = 4;
  inline ::google::protobuf::uint32 extra_data_offset() const;
  inline void set_extra_data_offset(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TxRequest.TxRequestDetailsType)
 private:
  inline void set_has_request_index();
  inline void clear_has_request_index();
  inline void set_has_tx_hash();
  inline void clear_has_tx_hash();
  inline void set_has_extra_data_len();
  inline void clear_has_extra_data_len();
  inline void set_has_extra_data_offset();
  inline void clear_has_extra_data_offset();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* tx_hash_;
  ::google::protobuf::uint32 request_index_;
  ::google::protobuf::uint32 extra_data_len_;
  ::google::protobuf::uint32 extra_data_offset_;
  friend void  protobuf_AddDesc_messages_2dbitcoin_2eproto();
  friend void protobuf_AssignDesc_messages_2dbitcoin_2eproto();
  friend void protobuf_ShutdownFile_messages_2dbitcoin_2eproto();

  void InitAsDefaultInstance();
  static TxRequest_TxRequestDetailsType* default_instance_;
};
// -------------------------------------------------------------------

class TxRequest_TxRequestSerializedType : public ::google::protobuf::Message {
 public:
  TxRequest_TxRequestSerializedType();
  virtual ~TxRequest_TxRequestSerializedType();

  TxRequest_TxRequestSerializedType(const TxRequest_TxRequestSerializedType& from);

  inline TxRequest_TxRequestSerializedType& operator=(const TxRequest_TxRequestSerializedType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TxRequest_TxRequestSerializedType& default_instance();

  void Swap(TxRequest_TxRequestSerializedType* other);

  // implements Message ----------------------------------------------

  TxRequest_TxRequestSerializedType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TxRequest_TxRequestSerializedType& from);
  void MergeFrom(const TxRequest_TxRequestSerializedType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 signature_index = 1;
  inline bool has_signature_index() const;
  inline void clear_signature_index();
  static const int kSignatureIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 signature_index() const;
  inline void set_signature_index(::google::protobuf::uint32 value);

  // optional bytes signature = 2;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 2;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const void* value, size_t size);
  inline ::std::string* mutable_signature();
  inline ::std::string* release_signature();
  inline void set_allocated_signature(::std::string* signature);

  // optional bytes serialized_tx = 3;
  inline bool has_serialized_tx() const;
  inline void clear_serialized_tx();
  static const int kSerializedTxFieldNumber = 3;
  inline const ::std::string& serialized_tx() const;
  inline void set_serialized_tx(const ::std::string& value);
  inline void set_serialized_tx(const char* value);
  inline void set_serialized_tx(const void* value, size_t size);
  inline ::std::string* mutable_serialized_tx();
  inline ::std::string* release_serialized_tx();
  inline void set_allocated_serialized_tx(::std::string* serialized_tx);

  // @@protoc_insertion_point(class_scope:TxRequest.TxRequestSerializedType)
 private:
  inline void set_has_signature_index();
  inline void clear_has_signature_index();
  inline void set_has_signature();
  inline void clear_has_signature();
  inline void set_has_serialized_tx();
  inline void clear_has_serialized_tx();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* signature_;
  ::std::string* serialized_tx_;
  ::google::protobuf::uint32 signature_index_;
  friend void  protobuf_AddDesc_messages_2dbitcoin_2eproto();
  friend void protobuf_AssignDesc_messages_2dbitcoin_2eproto();
  friend void protobuf_ShutdownFile_messages_2dbitcoin_2eproto();

  void InitAsDefaultInstance();
  static TxRequest_TxRequestSerializedType* default_instance_;
};
// -------------------------------------------------------------------

class TxRequest : public ::google::protobuf::Message {
 public:
  TxRequest();
  virtual ~TxRequest();

  TxRequest(const TxRequest& from);

  inline TxRequest& operator=(const TxRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TxRequest& default_instance();

  void Swap(TxRequest* other);

  // implements Message ----------------------------------------------

  TxRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TxRequest& from);
  void MergeFrom(const TxRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TxRequest_TxRequestDetailsType TxRequestDetailsType;
  typedef TxRequest_TxRequestSerializedType TxRequestSerializedType;

  typedef TxRequest_RequestType RequestType;
  static const RequestType TXINPUT = TxRequest_RequestType_TXINPUT;
  static const RequestType TXOUTPUT = TxRequest_RequestType_TXOUTPUT;
  static const RequestType TXMETA = TxRequest_RequestType_TXMETA;
  static const RequestType TXFINISHED = TxRequest_RequestType_TXFINISHED;
  static const RequestType TXEXTRADATA = TxRequest_RequestType_TXEXTRADATA;
  static inline bool RequestType_IsValid(int value) {
    return TxRequest_RequestType_IsValid(value);
  }
  static const RequestType RequestType_MIN =
    TxRequest_RequestType_RequestType_MIN;
  static const RequestType RequestType_MAX =
    TxRequest_RequestType_RequestType_MAX;
  static const int RequestType_ARRAYSIZE =
    TxRequest_RequestType_RequestType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RequestType_descriptor() {
    return TxRequest_RequestType_descriptor();
  }
  static inline const ::std::string& RequestType_Name(RequestType value) {
    return TxRequest_RequestType_Name(value);
  }
  static inline bool RequestType_Parse(const ::std::string& name,
      RequestType* value) {
    return TxRequest_RequestType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .TxRequest.RequestType request_type = 1;
  inline bool has_request_type() const;
  inline void clear_request_type();
  static const int kRequestTypeFieldNumber = 1;
  inline ::TxRequest_RequestType request_type() const;
  inline void set_request_type(::TxRequest_RequestType value);

  // optional .TxRequest.TxRequestDetailsType details = 2;
  inline bool has_details() const;
  inline void clear_details();
  static const int kDetailsFieldNumber = 2;
  inline const ::TxRequest_TxRequestDetailsType& details() const;
  inline ::TxRequest_TxRequestDetailsType* mutable_details();
  inline ::TxRequest_TxRequestDetailsType* release_details();
  inline void set_allocated_details(::TxRequest_TxRequestDetailsType* details);

  // optional .TxRequest.TxRequestSerializedType serialized = 3;
  inline bool has_serialized() const;
  inline void clear_serialized();
  static const int kSerializedFieldNumber = 3;
  inline const ::TxRequest_TxRequestSerializedType& serialized() const;
  inline ::TxRequest_TxRequestSerializedType* mutable_serialized();
  inline ::TxRequest_TxRequestSerializedType* release_serialized();
  inline void set_allocated_serialized(::TxRequest_TxRequestSerializedType* serialized);

  // @@protoc_insertion_point(class_scope:TxRequest)
 private:
  inline void set_has_request_type();
  inline void clear_has_request_type();
  inline void set_has_details();
  inline void clear_has_details();
  inline void set_has_serialized();
  inline void clear_has_serialized();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::TxRequest_TxRequestDetailsType* details_;
  ::TxRequest_TxRequestSerializedType* serialized_;
  int request_type_;
  friend void  protobuf_AddDesc_messages_2dbitcoin_2eproto();
  friend void protobuf_AssignDesc_messages_2dbitcoin_2eproto();
  friend void protobuf_ShutdownFile_messages_2dbitcoin_2eproto();

  void InitAsDefaultInstance();
  static TxRequest* default_instance_;
};
// -------------------------------------------------------------------

class TxAck_TransactionType_TxInputType : public ::google::protobuf::Message {
 public:
  TxAck_TransactionType_TxInputType();
  virtual ~TxAck_TransactionType_TxInputType();

  TxAck_TransactionType_TxInputType(const TxAck_TransactionType_TxInputType& from);

  inline TxAck_TransactionType_TxInputType& operator=(const TxAck_TransactionType_TxInputType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TxAck_TransactionType_TxInputType& default_instance();

  void Swap(TxAck_TransactionType_TxInputType* other);

  // implements Message ----------------------------------------------

  TxAck_TransactionType_TxInputType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TxAck_TransactionType_TxInputType& from);
  void MergeFrom(const TxAck_TransactionType_TxInputType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 1;
  inline int address_n_size() const;
  inline void clear_address_n();
  static const int kAddressNFieldNumber = 1;
  inline ::google::protobuf::uint32 address_n(int index) const;
  inline void set_address_n(int index, ::google::protobuf::uint32 value);
  inline void add_address_n(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // required bytes prev_hash = 2;
  inline bool has_prev_hash() const;
  inline void clear_prev_hash();
  static const int kPrevHashFieldNumber = 2;
  inline const ::std::string& prev_hash() const;
  inline void set_prev_hash(const ::std::string& value);
  inline void set_prev_hash(const char* value);
  inline void set_prev_hash(const void* value, size_t size);
  inline ::std::string* mutable_prev_hash();
  inline ::std::string* release_prev_hash();
  inline void set_allocated_prev_hash(::std::string* prev_hash);

  // required uint32 prev_index = 3;
  inline bool has_prev_index() const;
  inline void clear_prev_index();
  static const int kPrevIndexFieldNumber = 3;
  inline ::google::protobuf::uint32 prev_index() const;
  inline void set_prev_index(::google::protobuf::uint32 value);

  // optional bytes script_sig = 4;
  inline bool has_script_sig() const;
  inline void clear_script_sig();
  static const int kScriptSigFieldNumber = 4;
  inline const ::std::string& script_sig() const;
  inline void set_script_sig(const ::std::string& value);
  inline void set_script_sig(const char* value);
  inline void set_script_sig(const void* value, size_t size);
  inline ::std::string* mutable_script_sig();
  inline ::std::string* release_script_sig();
  inline void set_allocated_script_sig(::std::string* script_sig);

  // optional uint32 sequence = 5 [default = 4294967295];
  inline bool has_sequence() const;
  inline void clear_sequence();
  static const int kSequenceFieldNumber = 5;
  inline ::google::protobuf::uint32 sequence() const;
  inline void set_sequence(::google::protobuf::uint32 value);

  // optional .InputScriptType script_type = 6 [default = SPENDADDRESS];
  inline bool has_script_type() const;
  inline void clear_script_type();
  static const int kScriptTypeFieldNumber = 6;
  inline ::InputScriptType script_type() const;
  inline void set_script_type(::InputScriptType value);

  // optional .MultisigRedeemScriptType multisig = 7;
  inline bool has_multisig() const;
  inline void clear_multisig();
  static const int kMultisigFieldNumber = 7;
  inline const ::MultisigRedeemScriptType& multisig() const;
  inline ::MultisigRedeemScriptType* mutable_multisig();
  inline ::MultisigRedeemScriptType* release_multisig();
  inline void set_allocated_multisig(::MultisigRedeemScriptType* multisig);

  // optional uint64 amount = 8;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 8;
  inline ::google::protobuf::uint64 amount() const;
  inline void set_amount(::google::protobuf::uint64 value);

  // optional uint32 decred_tree = 9;
  inline bool has_decred_tree() const;
  inline void clear_decred_tree();
  static const int kDecredTreeFieldNumber = 9;
  inline ::google::protobuf::uint32 decred_tree() const;
  inline void set_decred_tree(::google::protobuf::uint32 value);

  // optional uint32 decred_script_version = 10;
  inline bool has_decred_script_version() const;
  inline void clear_decred_script_version();
  static const int kDecredScriptVersionFieldNumber = 10;
  inline ::google::protobuf::uint32 decred_script_version() const;
  inline void set_decred_script_version(::google::protobuf::uint32 value);

  // optional bytes prev_block_hash_bip115 = 11;
  inline bool has_prev_block_hash_bip115() const;
  inline void clear_prev_block_hash_bip115();
  static const int kPrevBlockHashBip115FieldNumber = 11;
  inline const ::std::string& prev_block_hash_bip115() const;
  inline void set_prev_block_hash_bip115(const ::std::string& value);
  inline void set_prev_block_hash_bip115(const char* value);
  inline void set_prev_block_hash_bip115(const void* value, size_t size);
  inline ::std::string* mutable_prev_block_hash_bip115();
  inline ::std::string* release_prev_block_hash_bip115();
  inline void set_allocated_prev_block_hash_bip115(::std::string* prev_block_hash_bip115);

  // optional uint32 prev_block_height_bip115 = 12;
  inline bool has_prev_block_height_bip115() const;
  inline void clear_prev_block_height_bip115();
  static const int kPrevBlockHeightBip115FieldNumber = 12;
  inline ::google::protobuf::uint32 prev_block_height_bip115() const;
  inline void set_prev_block_height_bip115(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TxAck.TransactionType.TxInputType)
 private:
  inline void set_has_prev_hash();
  inline void clear_has_prev_hash();
  inline void set_has_prev_index();
  inline void clear_has_prev_index();
  inline void set_has_script_sig();
  inline void clear_has_script_sig();
  inline void set_has_sequence();
  inline void clear_has_sequence();
  inline void set_has_script_type();
  inline void clear_has_script_type();
  inline void set_has_multisig();
  inline void clear_has_multisig();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_decred_tree();
  inline void clear_has_decred_tree();
  inline void set_has_decred_script_version();
  inline void clear_has_decred_script_version();
  inline void set_has_prev_block_hash_bip115();
  inline void clear_has_prev_block_hash_bip115();
  inline void set_has_prev_block_height_bip115();
  inline void clear_has_prev_block_height_bip115();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  ::std::string* prev_hash_;
  ::std::string* script_sig_;
  ::google::protobuf::uint32 prev_index_;
  ::google::protobuf::uint32 sequence_;
  ::MultisigRedeemScriptType* multisig_;
  int script_type_;
  ::google::protobuf::uint32 decred_tree_;
  ::google::protobuf::uint64 amount_;
  ::std::string* prev_block_hash_bip115_;
  ::google::protobuf::uint32 decred_script_version_;
  ::google::protobuf::uint32 prev_block_height_bip115_;
  friend void  protobuf_AddDesc_messages_2dbitcoin_2eproto();
  friend void protobuf_AssignDesc_messages_2dbitcoin_2eproto();
  friend void protobuf_ShutdownFile_messages_2dbitcoin_2eproto();

  void InitAsDefaultInstance();
  static TxAck_TransactionType_TxInputType* default_instance_;
};
// -------------------------------------------------------------------

class TxAck_TransactionType_TxOutputBinType : public ::google::protobuf::Message {
 public:
  TxAck_TransactionType_TxOutputBinType();
  virtual ~TxAck_TransactionType_TxOutputBinType();

  TxAck_TransactionType_TxOutputBinType(const TxAck_TransactionType_TxOutputBinType& from);

  inline TxAck_TransactionType_TxOutputBinType& operator=(const TxAck_TransactionType_TxOutputBinType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TxAck_TransactionType_TxOutputBinType& default_instance();

  void Swap(TxAck_TransactionType_TxOutputBinType* other);

  // implements Message ----------------------------------------------

  TxAck_TransactionType_TxOutputBinType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TxAck_TransactionType_TxOutputBinType& from);
  void MergeFrom(const TxAck_TransactionType_TxOutputBinType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 amount = 1;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 1;
  inline ::google::protobuf::uint64 amount() const;
  inline void set_amount(::google::protobuf::uint64 value);

  // required bytes script_pubkey = 2;
  inline bool has_script_pubkey() const;
  inline void clear_script_pubkey();
  static const int kScriptPubkeyFieldNumber = 2;
  inline const ::std::string& script_pubkey() const;
  inline void set_script_pubkey(const ::std::string& value);
  inline void set_script_pubkey(const char* value);
  inline void set_script_pubkey(const void* value, size_t size);
  inline ::std::string* mutable_script_pubkey();
  inline ::std::string* release_script_pubkey();
  inline void set_allocated_script_pubkey(::std::string* script_pubkey);

  // optional uint32 decred_script_version = 3;
  inline bool has_decred_script_version() const;
  inline void clear_decred_script_version();
  static const int kDecredScriptVersionFieldNumber = 3;
  inline ::google::protobuf::uint32 decred_script_version() const;
  inline void set_decred_script_version(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TxAck.TransactionType.TxOutputBinType)
 private:
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_script_pubkey();
  inline void clear_has_script_pubkey();
  inline void set_has_decred_script_version();
  inline void clear_has_decred_script_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 amount_;
  ::std::string* script_pubkey_;
  ::google::protobuf::uint32 decred_script_version_;
  friend void  protobuf_AddDesc_messages_2dbitcoin_2eproto();
  friend void protobuf_AssignDesc_messages_2dbitcoin_2eproto();
  friend void protobuf_ShutdownFile_messages_2dbitcoin_2eproto();

  void InitAsDefaultInstance();
  static TxAck_TransactionType_TxOutputBinType* default_instance_;
};
// -------------------------------------------------------------------

class TxAck_TransactionType_TxOutputType : public ::google::protobuf::Message {
 public:
  TxAck_TransactionType_TxOutputType();
  virtual ~TxAck_TransactionType_TxOutputType();

  TxAck_TransactionType_TxOutputType(const TxAck_TransactionType_TxOutputType& from);

  inline TxAck_TransactionType_TxOutputType& operator=(const TxAck_TransactionType_TxOutputType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TxAck_TransactionType_TxOutputType& default_instance();

  void Swap(TxAck_TransactionType_TxOutputType* other);

  // implements Message ----------------------------------------------

  TxAck_TransactionType_TxOutputType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TxAck_TransactionType_TxOutputType& from);
  void MergeFrom(const TxAck_TransactionType_TxOutputType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TxAck_TransactionType_TxOutputType_OutputScriptType OutputScriptType;
  static const OutputScriptType PAYTOADDRESS = TxAck_TransactionType_TxOutputType_OutputScriptType_PAYTOADDRESS;
  static const OutputScriptType PAYTOSCRIPTHASH = TxAck_TransactionType_TxOutputType_OutputScriptType_PAYTOSCRIPTHASH;
  static const OutputScriptType PAYTOMULTISIG = TxAck_TransactionType_TxOutputType_OutputScriptType_PAYTOMULTISIG;
  static const OutputScriptType PAYTOOPRETURN = TxAck_TransactionType_TxOutputType_OutputScriptType_PAYTOOPRETURN;
  static const OutputScriptType PAYTOWITNESS = TxAck_TransactionType_TxOutputType_OutputScriptType_PAYTOWITNESS;
  static const OutputScriptType PAYTOP2SHWITNESS = TxAck_TransactionType_TxOutputType_OutputScriptType_PAYTOP2SHWITNESS;
  static inline bool OutputScriptType_IsValid(int value) {
    return TxAck_TransactionType_TxOutputType_OutputScriptType_IsValid(value);
  }
  static const OutputScriptType OutputScriptType_MIN =
    TxAck_TransactionType_TxOutputType_OutputScriptType_OutputScriptType_MIN;
  static const OutputScriptType OutputScriptType_MAX =
    TxAck_TransactionType_TxOutputType_OutputScriptType_OutputScriptType_MAX;
  static const int OutputScriptType_ARRAYSIZE =
    TxAck_TransactionType_TxOutputType_OutputScriptType_OutputScriptType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  OutputScriptType_descriptor() {
    return TxAck_TransactionType_TxOutputType_OutputScriptType_descriptor();
  }
  static inline const ::std::string& OutputScriptType_Name(OutputScriptType value) {
    return TxAck_TransactionType_TxOutputType_OutputScriptType_Name(value);
  }
  static inline bool OutputScriptType_Parse(const ::std::string& name,
      OutputScriptType* value) {
    return TxAck_TransactionType_TxOutputType_OutputScriptType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string address = 1;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 1;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const char* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  inline void set_allocated_address(::std::string* address);

  // repeated uint32 address_n = 2;
  inline int address_n_size() const;
  inline void clear_address_n();
  static const int kAddressNFieldNumber = 2;
  inline ::google::protobuf::uint32 address_n(int index) const;
  inline void set_address_n(int index, ::google::protobuf::uint32 value);
  inline void add_address_n(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // required uint64 amount = 3;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 3;
  inline ::google::protobuf::uint64 amount() const;
  inline void set_amount(::google::protobuf::uint64 value);

  // required .TxAck.TransactionType.TxOutputType.OutputScriptType script_type = 4;
  inline bool has_script_type() const;
  inline void clear_script_type();
  static const int kScriptTypeFieldNumber = 4;
  inline ::TxAck_TransactionType_TxOutputType_OutputScriptType script_type() const;
  inline void set_script_type(::TxAck_TransactionType_TxOutputType_OutputScriptType value);

  // optional .MultisigRedeemScriptType multisig = 5;
  inline bool has_multisig() const;
  inline void clear_multisig();
  static const int kMultisigFieldNumber = 5;
  inline const ::MultisigRedeemScriptType& multisig() const;
  inline ::MultisigRedeemScriptType* mutable_multisig();
  inline ::MultisigRedeemScriptType* release_multisig();
  inline void set_allocated_multisig(::MultisigRedeemScriptType* multisig);

  // optional bytes op_return_data = 6;
  inline bool has_op_return_data() const;
  inline void clear_op_return_data();
  static const int kOpReturnDataFieldNumber = 6;
  inline const ::std::string& op_return_data() const;
  inline void set_op_return_data(const ::std::string& value);
  inline void set_op_return_data(const char* value);
  inline void set_op_return_data(const void* value, size_t size);
  inline ::std::string* mutable_op_return_data();
  inline ::std::string* release_op_return_data();
  inline void set_allocated_op_return_data(::std::string* op_return_data);

  // optional uint32 decred_script_version = 7;
  inline bool has_decred_script_version() const;
  inline void clear_decred_script_version();
  static const int kDecredScriptVersionFieldNumber = 7;
  inline ::google::protobuf::uint32 decred_script_version() const;
  inline void set_decred_script_version(::google::protobuf::uint32 value);

  // optional bytes block_hash_bip115 = 8;
  inline bool has_block_hash_bip115() const;
  inline void clear_block_hash_bip115();
  static const int kBlockHashBip115FieldNumber = 8;
  inline const ::std::string& block_hash_bip115() const;
  inline void set_block_hash_bip115(const ::std::string& value);
  inline void set_block_hash_bip115(const char* value);
  inline void set_block_hash_bip115(const void* value, size_t size);
  inline ::std::string* mutable_block_hash_bip115();
  inline ::std::string* release_block_hash_bip115();
  inline void set_allocated_block_hash_bip115(::std::string* block_hash_bip115);

  // optional uint32 block_height_bip115 = 9;
  inline bool has_block_height_bip115() const;
  inline void clear_block_height_bip115();
  static const int kBlockHeightBip115FieldNumber = 9;
  inline ::google::protobuf::uint32 block_height_bip115() const;
  inline void set_block_height_bip115(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TxAck.TransactionType.TxOutputType)
 private:
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_script_type();
  inline void clear_has_script_type();
  inline void set_has_multisig();
  inline void clear_has_multisig();
  inline void set_has_op_return_data();
  inline void clear_has_op_return_data();
  inline void set_has_decred_script_version();
  inline void clear_has_decred_script_version();
  inline void set_has_block_hash_bip115();
  inline void clear_has_block_hash_bip115();
  inline void set_has_block_height_bip115();
  inline void clear_has_block_height_bip115();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* address_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  ::google::protobuf::uint64 amount_;
  ::MultisigRedeemScriptType* multisig_;
  int script_type_;
  ::google::protobuf::uint32 decred_script_version_;
  ::std::string* op_return_data_;
  ::std::string* block_hash_bip115_;
  ::google::protobuf::uint32 block_height_bip115_;
  friend void  protobuf_AddDesc_messages_2dbitcoin_2eproto();
  friend void protobuf_AssignDesc_messages_2dbitcoin_2eproto();
  friend void protobuf_ShutdownFile_messages_2dbitcoin_2eproto();

  void InitAsDefaultInstance();
  static TxAck_TransactionType_TxOutputType* default_instance_;
};
// -------------------------------------------------------------------

class TxAck_TransactionType : public ::google::protobuf::Message {
 public:
  TxAck_TransactionType();
  virtual ~TxAck_TransactionType();

  TxAck_TransactionType(const TxAck_TransactionType& from);

  inline TxAck_TransactionType& operator=(const TxAck_TransactionType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TxAck_TransactionType& default_instance();

  void Swap(TxAck_TransactionType* other);

  // implements Message ----------------------------------------------

  TxAck_TransactionType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TxAck_TransactionType& from);
  void MergeFrom(const TxAck_TransactionType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TxAck_TransactionType_TxInputType TxInputType;
  typedef TxAck_TransactionType_TxOutputBinType TxOutputBinType;
  typedef TxAck_TransactionType_TxOutputType TxOutputType;

  // accessors -------------------------------------------------------

  // optional uint32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);

  // repeated .TxAck.TransactionType.TxInputType inputs = 2;
  inline int inputs_size() const;
  inline void clear_inputs();
  static const int kInputsFieldNumber = 2;
  inline const ::TxAck_TransactionType_TxInputType& inputs(int index) const;
  inline ::TxAck_TransactionType_TxInputType* mutable_inputs(int index);
  inline ::TxAck_TransactionType_TxInputType* add_inputs();
  inline const ::google::protobuf::RepeatedPtrField< ::TxAck_TransactionType_TxInputType >&
      inputs() const;
  inline ::google::protobuf::RepeatedPtrField< ::TxAck_TransactionType_TxInputType >*
      mutable_inputs();

  // repeated .TxAck.TransactionType.TxOutputBinType bin_outputs = 3;
  inline int bin_outputs_size() const;
  inline void clear_bin_outputs();
  static const int kBinOutputsFieldNumber = 3;
  inline const ::TxAck_TransactionType_TxOutputBinType& bin_outputs(int index) const;
  inline ::TxAck_TransactionType_TxOutputBinType* mutable_bin_outputs(int index);
  inline ::TxAck_TransactionType_TxOutputBinType* add_bin_outputs();
  inline const ::google::protobuf::RepeatedPtrField< ::TxAck_TransactionType_TxOutputBinType >&
      bin_outputs() const;
  inline ::google::protobuf::RepeatedPtrField< ::TxAck_TransactionType_TxOutputBinType >*
      mutable_bin_outputs();

  // optional uint32 lock_time = 4;
  inline bool has_lock_time() const;
  inline void clear_lock_time();
  static const int kLockTimeFieldNumber = 4;
  inline ::google::protobuf::uint32 lock_time() const;
  inline void set_lock_time(::google::protobuf::uint32 value);

  // repeated .TxAck.TransactionType.TxOutputType outputs = 5;
  inline int outputs_size() const;
  inline void clear_outputs();
  static const int kOutputsFieldNumber = 5;
  inline const ::TxAck_TransactionType_TxOutputType& outputs(int index) const;
  inline ::TxAck_TransactionType_TxOutputType* mutable_outputs(int index);
  inline ::TxAck_TransactionType_TxOutputType* add_outputs();
  inline const ::google::protobuf::RepeatedPtrField< ::TxAck_TransactionType_TxOutputType >&
      outputs() const;
  inline ::google::protobuf::RepeatedPtrField< ::TxAck_TransactionType_TxOutputType >*
      mutable_outputs();

  // optional uint32 inputs_cnt = 6;
  inline bool has_inputs_cnt() const;
  inline void clear_inputs_cnt();
  static const int kInputsCntFieldNumber = 6;
  inline ::google::protobuf::uint32 inputs_cnt() const;
  inline void set_inputs_cnt(::google::protobuf::uint32 value);

  // optional uint32 outputs_cnt = 7;
  inline bool has_outputs_cnt() const;
  inline void clear_outputs_cnt();
  static const int kOutputsCntFieldNumber = 7;
  inline ::google::protobuf::uint32 outputs_cnt() const;
  inline void set_outputs_cnt(::google::protobuf::uint32 value);

  // optional bytes extra_data = 8;
  inline bool has_extra_data() const;
  inline void clear_extra_data();
  static const int kExtraDataFieldNumber = 8;
  inline const ::std::string& extra_data() const;
  inline void set_extra_data(const ::std::string& value);
  inline void set_extra_data(const char* value);
  inline void set_extra_data(const void* value, size_t size);
  inline ::std::string* mutable_extra_data();
  inline ::std::string* release_extra_data();
  inline void set_allocated_extra_data(::std::string* extra_data);

  // optional uint32 extra_data_len = 9;
  inline bool has_extra_data_len() const;
  inline void clear_extra_data_len();
  static const int kExtraDataLenFieldNumber = 9;
  inline ::google::protobuf::uint32 extra_data_len() const;
  inline void set_extra_data_len(::google::protobuf::uint32 value);

  // optional uint32 expiry = 10;
  inline bool has_expiry() const;
  inline void clear_expiry();
  static const int kExpiryFieldNumber = 10;
  inline ::google::protobuf::uint32 expiry() const;
  inline void set_expiry(::google::protobuf::uint32 value);

  // optional bool overwintered = 11;
  inline bool has_overwintered() const;
  inline void clear_overwintered();
  static const int kOverwinteredFieldNumber = 11;
  inline bool overwintered() const;
  inline void set_overwintered(bool value);

  // @@protoc_insertion_point(class_scope:TxAck.TransactionType)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_lock_time();
  inline void clear_has_lock_time();
  inline void set_has_inputs_cnt();
  inline void clear_has_inputs_cnt();
  inline void set_has_outputs_cnt();
  inline void clear_has_outputs_cnt();
  inline void set_has_extra_data();
  inline void clear_has_extra_data();
  inline void set_has_extra_data_len();
  inline void clear_has_extra_data_len();
  inline void set_has_expiry();
  inline void clear_has_expiry();
  inline void set_has_overwintered();
  inline void clear_has_overwintered();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::TxAck_TransactionType_TxInputType > inputs_;
  ::google::protobuf::uint32 version_;
  ::google::protobuf::uint32 lock_time_;
  ::google::protobuf::RepeatedPtrField< ::TxAck_TransactionType_TxOutputBinType > bin_outputs_;
  ::google::protobuf::RepeatedPtrField< ::TxAck_TransactionType_TxOutputType > outputs_;
  ::google::protobuf::uint32 inputs_cnt_;
  ::google::protobuf::uint32 outputs_cnt_;
  ::std::string* extra_data_;
  ::google::protobuf::uint32 extra_data_len_;
  ::google::protobuf::uint32 expiry_;
  bool overwintered_;
  friend void  protobuf_AddDesc_messages_2dbitcoin_2eproto();
  friend void protobuf_AssignDesc_messages_2dbitcoin_2eproto();
  friend void protobuf_ShutdownFile_messages_2dbitcoin_2eproto();

  void InitAsDefaultInstance();
  static TxAck_TransactionType* default_instance_;
};
// -------------------------------------------------------------------

class TxAck : public ::google::protobuf::Message {
 public:
  TxAck();
  virtual ~TxAck();

  TxAck(const TxAck& from);

  inline TxAck& operator=(const TxAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TxAck& default_instance();

  void Swap(TxAck* other);

  // implements Message ----------------------------------------------

  TxAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TxAck& from);
  void MergeFrom(const TxAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TxAck_TransactionType TransactionType;

  // accessors -------------------------------------------------------

  // optional .TxAck.TransactionType tx = 1;
  inline bool has_tx() const;
  inline void clear_tx();
  static const int kTxFieldNumber = 1;
  inline const ::TxAck_TransactionType& tx() const;
  inline ::TxAck_TransactionType* mutable_tx();
  inline ::TxAck_TransactionType* release_tx();
  inline void set_allocated_tx(::TxAck_TransactionType* tx);

  // @@protoc_insertion_point(class_scope:TxAck)
 private:
  inline void set_has_tx();
  inline void clear_has_tx();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::TxAck_TransactionType* tx_;
  friend void  protobuf_AddDesc_messages_2dbitcoin_2eproto();
  friend void protobuf_AssignDesc_messages_2dbitcoin_2eproto();
  friend void protobuf_ShutdownFile_messages_2dbitcoin_2eproto();

  void InitAsDefaultInstance();
  static TxAck* default_instance_;
};
// ===================================================================


// ===================================================================

// MultisigRedeemScriptType_HDNodePathType

// required .HDNodeType node = 1;
inline bool MultisigRedeemScriptType_HDNodePathType::has_node() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MultisigRedeemScriptType_HDNodePathType::set_has_node() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MultisigRedeemScriptType_HDNodePathType::clear_has_node() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MultisigRedeemScriptType_HDNodePathType::clear_node() {
  if (node_ != NULL) node_->::HDNodeType::Clear();
  clear_has_node();
}
inline const ::HDNodeType& MultisigRedeemScriptType_HDNodePathType::node() const {
  // @@protoc_insertion_point(field_get:MultisigRedeemScriptType.HDNodePathType.node)
  return node_ != NULL ? *node_ : *default_instance_->node_;
}
inline ::HDNodeType* MultisigRedeemScriptType_HDNodePathType::mutable_node() {
  set_has_node();
  if (node_ == NULL) node_ = new ::HDNodeType;
  // @@protoc_insertion_point(field_mutable:MultisigRedeemScriptType.HDNodePathType.node)
  return node_;
}
inline ::HDNodeType* MultisigRedeemScriptType_HDNodePathType::release_node() {
  clear_has_node();
  ::HDNodeType* temp = node_;
  node_ = NULL;
  return temp;
}
inline void MultisigRedeemScriptType_HDNodePathType::set_allocated_node(::HDNodeType* node) {
  delete node_;
  node_ = node;
  if (node) {
    set_has_node();
  } else {
    clear_has_node();
  }
  // @@protoc_insertion_point(field_set_allocated:MultisigRedeemScriptType.HDNodePathType.node)
}

// repeated uint32 address_n = 2;
inline int MultisigRedeemScriptType_HDNodePathType::address_n_size() const {
  return address_n_.size();
}
inline void MultisigRedeemScriptType_HDNodePathType::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 MultisigRedeemScriptType_HDNodePathType::address_n(int index) const {
  // @@protoc_insertion_point(field_get:MultisigRedeemScriptType.HDNodePathType.address_n)
  return address_n_.Get(index);
}
inline void MultisigRedeemScriptType_HDNodePathType::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:MultisigRedeemScriptType.HDNodePathType.address_n)
}
inline void MultisigRedeemScriptType_HDNodePathType::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:MultisigRedeemScriptType.HDNodePathType.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
MultisigRedeemScriptType_HDNodePathType::address_n() const {
  // @@protoc_insertion_point(field_list:MultisigRedeemScriptType.HDNodePathType.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
MultisigRedeemScriptType_HDNodePathType::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:MultisigRedeemScriptType.HDNodePathType.address_n)
  return &address_n_;
}

// -------------------------------------------------------------------

// MultisigRedeemScriptType

// repeated .MultisigRedeemScriptType.HDNodePathType pubkeys = 1;
inline int MultisigRedeemScriptType::pubkeys_size() const {
  return pubkeys_.size();
}
inline void MultisigRedeemScriptType::clear_pubkeys() {
  pubkeys_.Clear();
}
inline const ::MultisigRedeemScriptType_HDNodePathType& MultisigRedeemScriptType::pubkeys(int index) const {
  // @@protoc_insertion_point(field_get:MultisigRedeemScriptType.pubkeys)
  return pubkeys_.Get(index);
}
inline ::MultisigRedeemScriptType_HDNodePathType* MultisigRedeemScriptType::mutable_pubkeys(int index) {
  // @@protoc_insertion_point(field_mutable:MultisigRedeemScriptType.pubkeys)
  return pubkeys_.Mutable(index);
}
inline ::MultisigRedeemScriptType_HDNodePathType* MultisigRedeemScriptType::add_pubkeys() {
  // @@protoc_insertion_point(field_add:MultisigRedeemScriptType.pubkeys)
  return pubkeys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MultisigRedeemScriptType_HDNodePathType >&
MultisigRedeemScriptType::pubkeys() const {
  // @@protoc_insertion_point(field_list:MultisigRedeemScriptType.pubkeys)
  return pubkeys_;
}
inline ::google::protobuf::RepeatedPtrField< ::MultisigRedeemScriptType_HDNodePathType >*
MultisigRedeemScriptType::mutable_pubkeys() {
  // @@protoc_insertion_point(field_mutable_list:MultisigRedeemScriptType.pubkeys)
  return &pubkeys_;
}

// repeated bytes signatures = 2;
inline int MultisigRedeemScriptType::signatures_size() const {
  return signatures_.size();
}
inline void MultisigRedeemScriptType::clear_signatures() {
  signatures_.Clear();
}
inline const ::std::string& MultisigRedeemScriptType::signatures(int index) const {
  // @@protoc_insertion_point(field_get:MultisigRedeemScriptType.signatures)
  return signatures_.Get(index);
}
inline ::std::string* MultisigRedeemScriptType::mutable_signatures(int index) {
  // @@protoc_insertion_point(field_mutable:MultisigRedeemScriptType.signatures)
  return signatures_.Mutable(index);
}
inline void MultisigRedeemScriptType::set_signatures(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:MultisigRedeemScriptType.signatures)
  signatures_.Mutable(index)->assign(value);
}
inline void MultisigRedeemScriptType::set_signatures(int index, const char* value) {
  signatures_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:MultisigRedeemScriptType.signatures)
}
inline void MultisigRedeemScriptType::set_signatures(int index, const void* value, size_t size) {
  signatures_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MultisigRedeemScriptType.signatures)
}
inline ::std::string* MultisigRedeemScriptType::add_signatures() {
  return signatures_.Add();
}
inline void MultisigRedeemScriptType::add_signatures(const ::std::string& value) {
  signatures_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:MultisigRedeemScriptType.signatures)
}
inline void MultisigRedeemScriptType::add_signatures(const char* value) {
  signatures_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:MultisigRedeemScriptType.signatures)
}
inline void MultisigRedeemScriptType::add_signatures(const void* value, size_t size) {
  signatures_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:MultisigRedeemScriptType.signatures)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MultisigRedeemScriptType::signatures() const {
  // @@protoc_insertion_point(field_list:MultisigRedeemScriptType.signatures)
  return signatures_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MultisigRedeemScriptType::mutable_signatures() {
  // @@protoc_insertion_point(field_mutable_list:MultisigRedeemScriptType.signatures)
  return &signatures_;
}

// optional uint32 m = 3;
inline bool MultisigRedeemScriptType::has_m() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MultisigRedeemScriptType::set_has_m() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MultisigRedeemScriptType::clear_has_m() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MultisigRedeemScriptType::clear_m() {
  m_ = 0u;
  clear_has_m();
}
inline ::google::protobuf::uint32 MultisigRedeemScriptType::m() const {
  // @@protoc_insertion_point(field_get:MultisigRedeemScriptType.m)
  return m_;
}
inline void MultisigRedeemScriptType::set_m(::google::protobuf::uint32 value) {
  set_has_m();
  m_ = value;
  // @@protoc_insertion_point(field_set:MultisigRedeemScriptType.m)
}

// -------------------------------------------------------------------

// GetPublicKey

// repeated uint32 address_n = 1;
inline int GetPublicKey::address_n_size() const {
  return address_n_.size();
}
inline void GetPublicKey::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 GetPublicKey::address_n(int index) const {
  // @@protoc_insertion_point(field_get:GetPublicKey.address_n)
  return address_n_.Get(index);
}
inline void GetPublicKey::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:GetPublicKey.address_n)
}
inline void GetPublicKey::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:GetPublicKey.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
GetPublicKey::address_n() const {
  // @@protoc_insertion_point(field_list:GetPublicKey.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
GetPublicKey::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:GetPublicKey.address_n)
  return &address_n_;
}

// optional string ecdsa_curve_name = 2;
inline bool GetPublicKey::has_ecdsa_curve_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetPublicKey::set_has_ecdsa_curve_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetPublicKey::clear_has_ecdsa_curve_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetPublicKey::clear_ecdsa_curve_name() {
  if (ecdsa_curve_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ecdsa_curve_name_->clear();
  }
  clear_has_ecdsa_curve_name();
}
inline const ::std::string& GetPublicKey::ecdsa_curve_name() const {
  // @@protoc_insertion_point(field_get:GetPublicKey.ecdsa_curve_name)
  return *ecdsa_curve_name_;
}
inline void GetPublicKey::set_ecdsa_curve_name(const ::std::string& value) {
  set_has_ecdsa_curve_name();
  if (ecdsa_curve_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ecdsa_curve_name_ = new ::std::string;
  }
  ecdsa_curve_name_->assign(value);
  // @@protoc_insertion_point(field_set:GetPublicKey.ecdsa_curve_name)
}
inline void GetPublicKey::set_ecdsa_curve_name(const char* value) {
  set_has_ecdsa_curve_name();
  if (ecdsa_curve_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ecdsa_curve_name_ = new ::std::string;
  }
  ecdsa_curve_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:GetPublicKey.ecdsa_curve_name)
}
inline void GetPublicKey::set_ecdsa_curve_name(const char* value, size_t size) {
  set_has_ecdsa_curve_name();
  if (ecdsa_curve_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ecdsa_curve_name_ = new ::std::string;
  }
  ecdsa_curve_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GetPublicKey.ecdsa_curve_name)
}
inline ::std::string* GetPublicKey::mutable_ecdsa_curve_name() {
  set_has_ecdsa_curve_name();
  if (ecdsa_curve_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ecdsa_curve_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GetPublicKey.ecdsa_curve_name)
  return ecdsa_curve_name_;
}
inline ::std::string* GetPublicKey::release_ecdsa_curve_name() {
  clear_has_ecdsa_curve_name();
  if (ecdsa_curve_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ecdsa_curve_name_;
    ecdsa_curve_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetPublicKey::set_allocated_ecdsa_curve_name(::std::string* ecdsa_curve_name) {
  if (ecdsa_curve_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ecdsa_curve_name_;
  }
  if (ecdsa_curve_name) {
    set_has_ecdsa_curve_name();
    ecdsa_curve_name_ = ecdsa_curve_name;
  } else {
    clear_has_ecdsa_curve_name();
    ecdsa_curve_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GetPublicKey.ecdsa_curve_name)
}

// optional bool show_display = 3;
inline bool GetPublicKey::has_show_display() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetPublicKey::set_has_show_display() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetPublicKey::clear_has_show_display() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetPublicKey::clear_show_display() {
  show_display_ = false;
  clear_has_show_display();
}
inline bool GetPublicKey::show_display() const {
  // @@protoc_insertion_point(field_get:GetPublicKey.show_display)
  return show_display_;
}
inline void GetPublicKey::set_show_display(bool value) {
  set_has_show_display();
  show_display_ = value;
  // @@protoc_insertion_point(field_set:GetPublicKey.show_display)
}

// optional string coin_name = 4 [default = "Bitcoin"];
inline bool GetPublicKey::has_coin_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetPublicKey::set_has_coin_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetPublicKey::clear_has_coin_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetPublicKey::clear_coin_name() {
  if (coin_name_ != _default_coin_name_) {
    coin_name_->assign(*_default_coin_name_);
  }
  clear_has_coin_name();
}
inline const ::std::string& GetPublicKey::coin_name() const {
  // @@protoc_insertion_point(field_get:GetPublicKey.coin_name)
  return *coin_name_;
}
inline void GetPublicKey::set_coin_name(const ::std::string& value) {
  set_has_coin_name();
  if (coin_name_ == _default_coin_name_) {
    coin_name_ = new ::std::string;
  }
  coin_name_->assign(value);
  // @@protoc_insertion_point(field_set:GetPublicKey.coin_name)
}
inline void GetPublicKey::set_coin_name(const char* value) {
  set_has_coin_name();
  if (coin_name_ == _default_coin_name_) {
    coin_name_ = new ::std::string;
  }
  coin_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:GetPublicKey.coin_name)
}
inline void GetPublicKey::set_coin_name(const char* value, size_t size) {
  set_has_coin_name();
  if (coin_name_ == _default_coin_name_) {
    coin_name_ = new ::std::string;
  }
  coin_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GetPublicKey.coin_name)
}
inline ::std::string* GetPublicKey::mutable_coin_name() {
  set_has_coin_name();
  if (coin_name_ == _default_coin_name_) {
    coin_name_ = new ::std::string(*_default_coin_name_);
  }
  // @@protoc_insertion_point(field_mutable:GetPublicKey.coin_name)
  return coin_name_;
}
inline ::std::string* GetPublicKey::release_coin_name() {
  clear_has_coin_name();
  if (coin_name_ == _default_coin_name_) {
    return NULL;
  } else {
    ::std::string* temp = coin_name_;
    coin_name_ = const_cast< ::std::string*>(_default_coin_name_);
    return temp;
  }
}
inline void GetPublicKey::set_allocated_coin_name(::std::string* coin_name) {
  if (coin_name_ != _default_coin_name_) {
    delete coin_name_;
  }
  if (coin_name) {
    set_has_coin_name();
    coin_name_ = coin_name;
  } else {
    clear_has_coin_name();
    coin_name_ = const_cast< ::std::string*>(_default_coin_name_);
  }
  // @@protoc_insertion_point(field_set_allocated:GetPublicKey.coin_name)
}

// -------------------------------------------------------------------

// PublicKey

// required .HDNodeType node = 1;
inline bool PublicKey::has_node() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PublicKey::set_has_node() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PublicKey::clear_has_node() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PublicKey::clear_node() {
  if (node_ != NULL) node_->::HDNodeType::Clear();
  clear_has_node();
}
inline const ::HDNodeType& PublicKey::node() const {
  // @@protoc_insertion_point(field_get:PublicKey.node)
  return node_ != NULL ? *node_ : *default_instance_->node_;
}
inline ::HDNodeType* PublicKey::mutable_node() {
  set_has_node();
  if (node_ == NULL) node_ = new ::HDNodeType;
  // @@protoc_insertion_point(field_mutable:PublicKey.node)
  return node_;
}
inline ::HDNodeType* PublicKey::release_node() {
  clear_has_node();
  ::HDNodeType* temp = node_;
  node_ = NULL;
  return temp;
}
inline void PublicKey::set_allocated_node(::HDNodeType* node) {
  delete node_;
  node_ = node;
  if (node) {
    set_has_node();
  } else {
    clear_has_node();
  }
  // @@protoc_insertion_point(field_set_allocated:PublicKey.node)
}

// optional string xpub = 2;
inline bool PublicKey::has_xpub() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PublicKey::set_has_xpub() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PublicKey::clear_has_xpub() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PublicKey::clear_xpub() {
  if (xpub_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    xpub_->clear();
  }
  clear_has_xpub();
}
inline const ::std::string& PublicKey::xpub() const {
  // @@protoc_insertion_point(field_get:PublicKey.xpub)
  return *xpub_;
}
inline void PublicKey::set_xpub(const ::std::string& value) {
  set_has_xpub();
  if (xpub_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    xpub_ = new ::std::string;
  }
  xpub_->assign(value);
  // @@protoc_insertion_point(field_set:PublicKey.xpub)
}
inline void PublicKey::set_xpub(const char* value) {
  set_has_xpub();
  if (xpub_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    xpub_ = new ::std::string;
  }
  xpub_->assign(value);
  // @@protoc_insertion_point(field_set_char:PublicKey.xpub)
}
inline void PublicKey::set_xpub(const char* value, size_t size) {
  set_has_xpub();
  if (xpub_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    xpub_ = new ::std::string;
  }
  xpub_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PublicKey.xpub)
}
inline ::std::string* PublicKey::mutable_xpub() {
  set_has_xpub();
  if (xpub_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    xpub_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PublicKey.xpub)
  return xpub_;
}
inline ::std::string* PublicKey::release_xpub() {
  clear_has_xpub();
  if (xpub_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = xpub_;
    xpub_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PublicKey::set_allocated_xpub(::std::string* xpub) {
  if (xpub_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete xpub_;
  }
  if (xpub) {
    set_has_xpub();
    xpub_ = xpub;
  } else {
    clear_has_xpub();
    xpub_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PublicKey.xpub)
}

// -------------------------------------------------------------------

// GetAddress

// repeated uint32 address_n = 1;
inline int GetAddress::address_n_size() const {
  return address_n_.size();
}
inline void GetAddress::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 GetAddress::address_n(int index) const {
  // @@protoc_insertion_point(field_get:GetAddress.address_n)
  return address_n_.Get(index);
}
inline void GetAddress::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:GetAddress.address_n)
}
inline void GetAddress::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:GetAddress.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
GetAddress::address_n() const {
  // @@protoc_insertion_point(field_list:GetAddress.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
GetAddress::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:GetAddress.address_n)
  return &address_n_;
}

// optional string coin_name = 2 [default = "Bitcoin"];
inline bool GetAddress::has_coin_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetAddress::set_has_coin_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetAddress::clear_has_coin_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetAddress::clear_coin_name() {
  if (coin_name_ != _default_coin_name_) {
    coin_name_->assign(*_default_coin_name_);
  }
  clear_has_coin_name();
}
inline const ::std::string& GetAddress::coin_name() const {
  // @@protoc_insertion_point(field_get:GetAddress.coin_name)
  return *coin_name_;
}
inline void GetAddress::set_coin_name(const ::std::string& value) {
  set_has_coin_name();
  if (coin_name_ == _default_coin_name_) {
    coin_name_ = new ::std::string;
  }
  coin_name_->assign(value);
  // @@protoc_insertion_point(field_set:GetAddress.coin_name)
}
inline void GetAddress::set_coin_name(const char* value) {
  set_has_coin_name();
  if (coin_name_ == _default_coin_name_) {
    coin_name_ = new ::std::string;
  }
  coin_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:GetAddress.coin_name)
}
inline void GetAddress::set_coin_name(const char* value, size_t size) {
  set_has_coin_name();
  if (coin_name_ == _default_coin_name_) {
    coin_name_ = new ::std::string;
  }
  coin_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GetAddress.coin_name)
}
inline ::std::string* GetAddress::mutable_coin_name() {
  set_has_coin_name();
  if (coin_name_ == _default_coin_name_) {
    coin_name_ = new ::std::string(*_default_coin_name_);
  }
  // @@protoc_insertion_point(field_mutable:GetAddress.coin_name)
  return coin_name_;
}
inline ::std::string* GetAddress::release_coin_name() {
  clear_has_coin_name();
  if (coin_name_ == _default_coin_name_) {
    return NULL;
  } else {
    ::std::string* temp = coin_name_;
    coin_name_ = const_cast< ::std::string*>(_default_coin_name_);
    return temp;
  }
}
inline void GetAddress::set_allocated_coin_name(::std::string* coin_name) {
  if (coin_name_ != _default_coin_name_) {
    delete coin_name_;
  }
  if (coin_name) {
    set_has_coin_name();
    coin_name_ = coin_name;
  } else {
    clear_has_coin_name();
    coin_name_ = const_cast< ::std::string*>(_default_coin_name_);
  }
  // @@protoc_insertion_point(field_set_allocated:GetAddress.coin_name)
}

// optional bool show_display = 3;
inline bool GetAddress::has_show_display() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetAddress::set_has_show_display() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetAddress::clear_has_show_display() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetAddress::clear_show_display() {
  show_display_ = false;
  clear_has_show_display();
}
inline bool GetAddress::show_display() const {
  // @@protoc_insertion_point(field_get:GetAddress.show_display)
  return show_display_;
}
inline void GetAddress::set_show_display(bool value) {
  set_has_show_display();
  show_display_ = value;
  // @@protoc_insertion_point(field_set:GetAddress.show_display)
}

// optional .MultisigRedeemScriptType multisig = 4;
inline bool GetAddress::has_multisig() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetAddress::set_has_multisig() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetAddress::clear_has_multisig() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetAddress::clear_multisig() {
  if (multisig_ != NULL) multisig_->::MultisigRedeemScriptType::Clear();
  clear_has_multisig();
}
inline const ::MultisigRedeemScriptType& GetAddress::multisig() const {
  // @@protoc_insertion_point(field_get:GetAddress.multisig)
  return multisig_ != NULL ? *multisig_ : *default_instance_->multisig_;
}
inline ::MultisigRedeemScriptType* GetAddress::mutable_multisig() {
  set_has_multisig();
  if (multisig_ == NULL) multisig_ = new ::MultisigRedeemScriptType;
  // @@protoc_insertion_point(field_mutable:GetAddress.multisig)
  return multisig_;
}
inline ::MultisigRedeemScriptType* GetAddress::release_multisig() {
  clear_has_multisig();
  ::MultisigRedeemScriptType* temp = multisig_;
  multisig_ = NULL;
  return temp;
}
inline void GetAddress::set_allocated_multisig(::MultisigRedeemScriptType* multisig) {
  delete multisig_;
  multisig_ = multisig;
  if (multisig) {
    set_has_multisig();
  } else {
    clear_has_multisig();
  }
  // @@protoc_insertion_point(field_set_allocated:GetAddress.multisig)
}

// optional .InputScriptType script_type = 5 [default = SPENDADDRESS];
inline bool GetAddress::has_script_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetAddress::set_has_script_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetAddress::clear_has_script_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetAddress::clear_script_type() {
  script_type_ = 0;
  clear_has_script_type();
}
inline ::InputScriptType GetAddress::script_type() const {
  // @@protoc_insertion_point(field_get:GetAddress.script_type)
  return static_cast< ::InputScriptType >(script_type_);
}
inline void GetAddress::set_script_type(::InputScriptType value) {
  assert(::InputScriptType_IsValid(value));
  set_has_script_type();
  script_type_ = value;
  // @@protoc_insertion_point(field_set:GetAddress.script_type)
}

// -------------------------------------------------------------------

// Address

// required string address = 1;
inline bool Address::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Address::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Address::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Address::clear_address() {
  if (address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& Address::address() const {
  // @@protoc_insertion_point(field_get:Address.address)
  return *address_;
}
inline void Address::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  address_->assign(value);
  // @@protoc_insertion_point(field_set:Address.address)
}
inline void Address::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  address_->assign(value);
  // @@protoc_insertion_point(field_set_char:Address.address)
}
inline void Address::set_address(const char* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Address.address)
}
inline ::std::string* Address::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Address.address)
  return address_;
}
inline ::std::string* Address::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Address::set_allocated_address(::std::string* address) {
  if (address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete address_;
  }
  if (address) {
    set_has_address();
    address_ = address;
  } else {
    clear_has_address();
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Address.address)
}

// -------------------------------------------------------------------

// SignMessage

// repeated uint32 address_n = 1;
inline int SignMessage::address_n_size() const {
  return address_n_.size();
}
inline void SignMessage::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 SignMessage::address_n(int index) const {
  // @@protoc_insertion_point(field_get:SignMessage.address_n)
  return address_n_.Get(index);
}
inline void SignMessage::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:SignMessage.address_n)
}
inline void SignMessage::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:SignMessage.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
SignMessage::address_n() const {
  // @@protoc_insertion_point(field_list:SignMessage.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
SignMessage::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:SignMessage.address_n)
  return &address_n_;
}

// required bytes message = 2;
inline bool SignMessage::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignMessage::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignMessage::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignMessage::clear_message() {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& SignMessage::message() const {
  // @@protoc_insertion_point(field_get:SignMessage.message)
  return *message_;
}
inline void SignMessage::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set:SignMessage.message)
}
inline void SignMessage::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set_char:SignMessage.message)
}
inline void SignMessage::set_message(const void* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SignMessage.message)
}
inline ::std::string* SignMessage::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:SignMessage.message)
  return message_;
}
inline ::std::string* SignMessage::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SignMessage::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:SignMessage.message)
}

// optional string coin_name = 3 [default = "Bitcoin"];
inline bool SignMessage::has_coin_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SignMessage::set_has_coin_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SignMessage::clear_has_coin_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SignMessage::clear_coin_name() {
  if (coin_name_ != _default_coin_name_) {
    coin_name_->assign(*_default_coin_name_);
  }
  clear_has_coin_name();
}
inline const ::std::string& SignMessage::coin_name() const {
  // @@protoc_insertion_point(field_get:SignMessage.coin_name)
  return *coin_name_;
}
inline void SignMessage::set_coin_name(const ::std::string& value) {
  set_has_coin_name();
  if (coin_name_ == _default_coin_name_) {
    coin_name_ = new ::std::string;
  }
  coin_name_->assign(value);
  // @@protoc_insertion_point(field_set:SignMessage.coin_name)
}
inline void SignMessage::set_coin_name(const char* value) {
  set_has_coin_name();
  if (coin_name_ == _default_coin_name_) {
    coin_name_ = new ::std::string;
  }
  coin_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:SignMessage.coin_name)
}
inline void SignMessage::set_coin_name(const char* value, size_t size) {
  set_has_coin_name();
  if (coin_name_ == _default_coin_name_) {
    coin_name_ = new ::std::string;
  }
  coin_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SignMessage.coin_name)
}
inline ::std::string* SignMessage::mutable_coin_name() {
  set_has_coin_name();
  if (coin_name_ == _default_coin_name_) {
    coin_name_ = new ::std::string(*_default_coin_name_);
  }
  // @@protoc_insertion_point(field_mutable:SignMessage.coin_name)
  return coin_name_;
}
inline ::std::string* SignMessage::release_coin_name() {
  clear_has_coin_name();
  if (coin_name_ == _default_coin_name_) {
    return NULL;
  } else {
    ::std::string* temp = coin_name_;
    coin_name_ = const_cast< ::std::string*>(_default_coin_name_);
    return temp;
  }
}
inline void SignMessage::set_allocated_coin_name(::std::string* coin_name) {
  if (coin_name_ != _default_coin_name_) {
    delete coin_name_;
  }
  if (coin_name) {
    set_has_coin_name();
    coin_name_ = coin_name;
  } else {
    clear_has_coin_name();
    coin_name_ = const_cast< ::std::string*>(_default_coin_name_);
  }
  // @@protoc_insertion_point(field_set_allocated:SignMessage.coin_name)
}

// optional .InputScriptType script_type = 4 [default = SPENDADDRESS];
inline bool SignMessage::has_script_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SignMessage::set_has_script_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SignMessage::clear_has_script_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SignMessage::clear_script_type() {
  script_type_ = 0;
  clear_has_script_type();
}
inline ::InputScriptType SignMessage::script_type() const {
  // @@protoc_insertion_point(field_get:SignMessage.script_type)
  return static_cast< ::InputScriptType >(script_type_);
}
inline void SignMessage::set_script_type(::InputScriptType value) {
  assert(::InputScriptType_IsValid(value));
  set_has_script_type();
  script_type_ = value;
  // @@protoc_insertion_point(field_set:SignMessage.script_type)
}

// -------------------------------------------------------------------

// MessageSignature

// optional string address = 1;
inline bool MessageSignature::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageSignature::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageSignature::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageSignature::clear_address() {
  if (address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& MessageSignature::address() const {
  // @@protoc_insertion_point(field_get:MessageSignature.address)
  return *address_;
}
inline void MessageSignature::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  address_->assign(value);
  // @@protoc_insertion_point(field_set:MessageSignature.address)
}
inline void MessageSignature::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  address_->assign(value);
  // @@protoc_insertion_point(field_set_char:MessageSignature.address)
}
inline void MessageSignature::set_address(const char* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MessageSignature.address)
}
inline ::std::string* MessageSignature::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:MessageSignature.address)
  return address_;
}
inline ::std::string* MessageSignature::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MessageSignature::set_allocated_address(::std::string* address) {
  if (address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete address_;
  }
  if (address) {
    set_has_address();
    address_ = address;
  } else {
    clear_has_address();
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:MessageSignature.address)
}

// optional bytes signature = 2;
inline bool MessageSignature::has_signature() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MessageSignature::set_has_signature() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MessageSignature::clear_has_signature() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MessageSignature::clear_signature() {
  if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_->clear();
  }
  clear_has_signature();
}
inline const ::std::string& MessageSignature::signature() const {
  // @@protoc_insertion_point(field_get:MessageSignature.signature)
  return *signature_;
}
inline void MessageSignature::set_signature(const ::std::string& value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
  // @@protoc_insertion_point(field_set:MessageSignature.signature)
}
inline void MessageSignature::set_signature(const char* value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
  // @@protoc_insertion_point(field_set_char:MessageSignature.signature)
}
inline void MessageSignature::set_signature(const void* value, size_t size) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MessageSignature.signature)
}
inline ::std::string* MessageSignature::mutable_signature() {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:MessageSignature.signature)
  return signature_;
}
inline ::std::string* MessageSignature::release_signature() {
  clear_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = signature_;
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MessageSignature::set_allocated_signature(::std::string* signature) {
  if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete signature_;
  }
  if (signature) {
    set_has_signature();
    signature_ = signature;
  } else {
    clear_has_signature();
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:MessageSignature.signature)
}

// -------------------------------------------------------------------

// VerifyMessage

// optional string address = 1;
inline bool VerifyMessage::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VerifyMessage::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VerifyMessage::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VerifyMessage::clear_address() {
  if (address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& VerifyMessage::address() const {
  // @@protoc_insertion_point(field_get:VerifyMessage.address)
  return *address_;
}
inline void VerifyMessage::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  address_->assign(value);
  // @@protoc_insertion_point(field_set:VerifyMessage.address)
}
inline void VerifyMessage::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  address_->assign(value);
  // @@protoc_insertion_point(field_set_char:VerifyMessage.address)
}
inline void VerifyMessage::set_address(const char* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:VerifyMessage.address)
}
inline ::std::string* VerifyMessage::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:VerifyMessage.address)
  return address_;
}
inline ::std::string* VerifyMessage::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VerifyMessage::set_allocated_address(::std::string* address) {
  if (address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete address_;
  }
  if (address) {
    set_has_address();
    address_ = address;
  } else {
    clear_has_address();
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:VerifyMessage.address)
}

// optional bytes signature = 2;
inline bool VerifyMessage::has_signature() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VerifyMessage::set_has_signature() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VerifyMessage::clear_has_signature() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VerifyMessage::clear_signature() {
  if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_->clear();
  }
  clear_has_signature();
}
inline const ::std::string& VerifyMessage::signature() const {
  // @@protoc_insertion_point(field_get:VerifyMessage.signature)
  return *signature_;
}
inline void VerifyMessage::set_signature(const ::std::string& value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
  // @@protoc_insertion_point(field_set:VerifyMessage.signature)
}
inline void VerifyMessage::set_signature(const char* value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
  // @@protoc_insertion_point(field_set_char:VerifyMessage.signature)
}
inline void VerifyMessage::set_signature(const void* value, size_t size) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:VerifyMessage.signature)
}
inline ::std::string* VerifyMessage::mutable_signature() {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:VerifyMessage.signature)
  return signature_;
}
inline ::std::string* VerifyMessage::release_signature() {
  clear_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = signature_;
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VerifyMessage::set_allocated_signature(::std::string* signature) {
  if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete signature_;
  }
  if (signature) {
    set_has_signature();
    signature_ = signature;
  } else {
    clear_has_signature();
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:VerifyMessage.signature)
}

// optional bytes message = 3;
inline bool VerifyMessage::has_message() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VerifyMessage::set_has_message() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VerifyMessage::clear_has_message() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VerifyMessage::clear_message() {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& VerifyMessage::message() const {
  // @@protoc_insertion_point(field_get:VerifyMessage.message)
  return *message_;
}
inline void VerifyMessage::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set:VerifyMessage.message)
}
inline void VerifyMessage::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set_char:VerifyMessage.message)
}
inline void VerifyMessage::set_message(const void* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:VerifyMessage.message)
}
inline ::std::string* VerifyMessage::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:VerifyMessage.message)
  return message_;
}
inline ::std::string* VerifyMessage::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VerifyMessage::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:VerifyMessage.message)
}

// optional string coin_name = 4 [default = "Bitcoin"];
inline bool VerifyMessage::has_coin_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VerifyMessage::set_has_coin_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VerifyMessage::clear_has_coin_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VerifyMessage::clear_coin_name() {
  if (coin_name_ != _default_coin_name_) {
    coin_name_->assign(*_default_coin_name_);
  }
  clear_has_coin_name();
}
inline const ::std::string& VerifyMessage::coin_name() const {
  // @@protoc_insertion_point(field_get:VerifyMessage.coin_name)
  return *coin_name_;
}
inline void VerifyMessage::set_coin_name(const ::std::string& value) {
  set_has_coin_name();
  if (coin_name_ == _default_coin_name_) {
    coin_name_ = new ::std::string;
  }
  coin_name_->assign(value);
  // @@protoc_insertion_point(field_set:VerifyMessage.coin_name)
}
inline void VerifyMessage::set_coin_name(const char* value) {
  set_has_coin_name();
  if (coin_name_ == _default_coin_name_) {
    coin_name_ = new ::std::string;
  }
  coin_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:VerifyMessage.coin_name)
}
inline void VerifyMessage::set_coin_name(const char* value, size_t size) {
  set_has_coin_name();
  if (coin_name_ == _default_coin_name_) {
    coin_name_ = new ::std::string;
  }
  coin_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:VerifyMessage.coin_name)
}
inline ::std::string* VerifyMessage::mutable_coin_name() {
  set_has_coin_name();
  if (coin_name_ == _default_coin_name_) {
    coin_name_ = new ::std::string(*_default_coin_name_);
  }
  // @@protoc_insertion_point(field_mutable:VerifyMessage.coin_name)
  return coin_name_;
}
inline ::std::string* VerifyMessage::release_coin_name() {
  clear_has_coin_name();
  if (coin_name_ == _default_coin_name_) {
    return NULL;
  } else {
    ::std::string* temp = coin_name_;
    coin_name_ = const_cast< ::std::string*>(_default_coin_name_);
    return temp;
  }
}
inline void VerifyMessage::set_allocated_coin_name(::std::string* coin_name) {
  if (coin_name_ != _default_coin_name_) {
    delete coin_name_;
  }
  if (coin_name) {
    set_has_coin_name();
    coin_name_ = coin_name;
  } else {
    clear_has_coin_name();
    coin_name_ = const_cast< ::std::string*>(_default_coin_name_);
  }
  // @@protoc_insertion_point(field_set_allocated:VerifyMessage.coin_name)
}

// -------------------------------------------------------------------

// SignTx

// required uint32 outputs_count = 1;
inline bool SignTx::has_outputs_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignTx::set_has_outputs_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignTx::clear_has_outputs_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignTx::clear_outputs_count() {
  outputs_count_ = 0u;
  clear_has_outputs_count();
}
inline ::google::protobuf::uint32 SignTx::outputs_count() const {
  // @@protoc_insertion_point(field_get:SignTx.outputs_count)
  return outputs_count_;
}
inline void SignTx::set_outputs_count(::google::protobuf::uint32 value) {
  set_has_outputs_count();
  outputs_count_ = value;
  // @@protoc_insertion_point(field_set:SignTx.outputs_count)
}

// required uint32 inputs_count = 2;
inline bool SignTx::has_inputs_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignTx::set_has_inputs_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignTx::clear_has_inputs_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignTx::clear_inputs_count() {
  inputs_count_ = 0u;
  clear_has_inputs_count();
}
inline ::google::protobuf::uint32 SignTx::inputs_count() const {
  // @@protoc_insertion_point(field_get:SignTx.inputs_count)
  return inputs_count_;
}
inline void SignTx::set_inputs_count(::google::protobuf::uint32 value) {
  set_has_inputs_count();
  inputs_count_ = value;
  // @@protoc_insertion_point(field_set:SignTx.inputs_count)
}

// optional string coin_name = 3 [default = "Bitcoin"];
inline bool SignTx::has_coin_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SignTx::set_has_coin_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SignTx::clear_has_coin_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SignTx::clear_coin_name() {
  if (coin_name_ != _default_coin_name_) {
    coin_name_->assign(*_default_coin_name_);
  }
  clear_has_coin_name();
}
inline const ::std::string& SignTx::coin_name() const {
  // @@protoc_insertion_point(field_get:SignTx.coin_name)
  return *coin_name_;
}
inline void SignTx::set_coin_name(const ::std::string& value) {
  set_has_coin_name();
  if (coin_name_ == _default_coin_name_) {
    coin_name_ = new ::std::string;
  }
  coin_name_->assign(value);
  // @@protoc_insertion_point(field_set:SignTx.coin_name)
}
inline void SignTx::set_coin_name(const char* value) {
  set_has_coin_name();
  if (coin_name_ == _default_coin_name_) {
    coin_name_ = new ::std::string;
  }
  coin_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:SignTx.coin_name)
}
inline void SignTx::set_coin_name(const char* value, size_t size) {
  set_has_coin_name();
  if (coin_name_ == _default_coin_name_) {
    coin_name_ = new ::std::string;
  }
  coin_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SignTx.coin_name)
}
inline ::std::string* SignTx::mutable_coin_name() {
  set_has_coin_name();
  if (coin_name_ == _default_coin_name_) {
    coin_name_ = new ::std::string(*_default_coin_name_);
  }
  // @@protoc_insertion_point(field_mutable:SignTx.coin_name)
  return coin_name_;
}
inline ::std::string* SignTx::release_coin_name() {
  clear_has_coin_name();
  if (coin_name_ == _default_coin_name_) {
    return NULL;
  } else {
    ::std::string* temp = coin_name_;
    coin_name_ = const_cast< ::std::string*>(_default_coin_name_);
    return temp;
  }
}
inline void SignTx::set_allocated_coin_name(::std::string* coin_name) {
  if (coin_name_ != _default_coin_name_) {
    delete coin_name_;
  }
  if (coin_name) {
    set_has_coin_name();
    coin_name_ = coin_name;
  } else {
    clear_has_coin_name();
    coin_name_ = const_cast< ::std::string*>(_default_coin_name_);
  }
  // @@protoc_insertion_point(field_set_allocated:SignTx.coin_name)
}

// optional uint32 version = 4 [default = 1];
inline bool SignTx::has_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SignTx::set_has_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SignTx::clear_has_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SignTx::clear_version() {
  version_ = 1u;
  clear_has_version();
}
inline ::google::protobuf::uint32 SignTx::version() const {
  // @@protoc_insertion_point(field_get:SignTx.version)
  return version_;
}
inline void SignTx::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:SignTx.version)
}

// optional uint32 lock_time = 5 [default = 0];
inline bool SignTx::has_lock_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SignTx::set_has_lock_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SignTx::clear_has_lock_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SignTx::clear_lock_time() {
  lock_time_ = 0u;
  clear_has_lock_time();
}
inline ::google::protobuf::uint32 SignTx::lock_time() const {
  // @@protoc_insertion_point(field_get:SignTx.lock_time)
  return lock_time_;
}
inline void SignTx::set_lock_time(::google::protobuf::uint32 value) {
  set_has_lock_time();
  lock_time_ = value;
  // @@protoc_insertion_point(field_set:SignTx.lock_time)
}

// optional uint32 expiry = 6;
inline bool SignTx::has_expiry() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SignTx::set_has_expiry() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SignTx::clear_has_expiry() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SignTx::clear_expiry() {
  expiry_ = 0u;
  clear_has_expiry();
}
inline ::google::protobuf::uint32 SignTx::expiry() const {
  // @@protoc_insertion_point(field_get:SignTx.expiry)
  return expiry_;
}
inline void SignTx::set_expiry(::google::protobuf::uint32 value) {
  set_has_expiry();
  expiry_ = value;
  // @@protoc_insertion_point(field_set:SignTx.expiry)
}

// optional bool overwintered = 7;
inline bool SignTx::has_overwintered() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SignTx::set_has_overwintered() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SignTx::clear_has_overwintered() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SignTx::clear_overwintered() {
  overwintered_ = false;
  clear_has_overwintered();
}
inline bool SignTx::overwintered() const {
  // @@protoc_insertion_point(field_get:SignTx.overwintered)
  return overwintered_;
}
inline void SignTx::set_overwintered(bool value) {
  set_has_overwintered();
  overwintered_ = value;
  // @@protoc_insertion_point(field_set:SignTx.overwintered)
}

// -------------------------------------------------------------------

// TxRequest_TxRequestDetailsType

// optional uint32 request_index = 1;
inline bool TxRequest_TxRequestDetailsType::has_request_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TxRequest_TxRequestDetailsType::set_has_request_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TxRequest_TxRequestDetailsType::clear_has_request_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TxRequest_TxRequestDetailsType::clear_request_index() {
  request_index_ = 0u;
  clear_has_request_index();
}
inline ::google::protobuf::uint32 TxRequest_TxRequestDetailsType::request_index() const {
  // @@protoc_insertion_point(field_get:TxRequest.TxRequestDetailsType.request_index)
  return request_index_;
}
inline void TxRequest_TxRequestDetailsType::set_request_index(::google::protobuf::uint32 value) {
  set_has_request_index();
  request_index_ = value;
  // @@protoc_insertion_point(field_set:TxRequest.TxRequestDetailsType.request_index)
}

// optional bytes tx_hash = 2;
inline bool TxRequest_TxRequestDetailsType::has_tx_hash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TxRequest_TxRequestDetailsType::set_has_tx_hash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TxRequest_TxRequestDetailsType::clear_has_tx_hash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TxRequest_TxRequestDetailsType::clear_tx_hash() {
  if (tx_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tx_hash_->clear();
  }
  clear_has_tx_hash();
}
inline const ::std::string& TxRequest_TxRequestDetailsType::tx_hash() const {
  // @@protoc_insertion_point(field_get:TxRequest.TxRequestDetailsType.tx_hash)
  return *tx_hash_;
}
inline void TxRequest_TxRequestDetailsType::set_tx_hash(const ::std::string& value) {
  set_has_tx_hash();
  if (tx_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tx_hash_ = new ::std::string;
  }
  tx_hash_->assign(value);
  // @@protoc_insertion_point(field_set:TxRequest.TxRequestDetailsType.tx_hash)
}
inline void TxRequest_TxRequestDetailsType::set_tx_hash(const char* value) {
  set_has_tx_hash();
  if (tx_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tx_hash_ = new ::std::string;
  }
  tx_hash_->assign(value);
  // @@protoc_insertion_point(field_set_char:TxRequest.TxRequestDetailsType.tx_hash)
}
inline void TxRequest_TxRequestDetailsType::set_tx_hash(const void* value, size_t size) {
  set_has_tx_hash();
  if (tx_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tx_hash_ = new ::std::string;
  }
  tx_hash_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TxRequest.TxRequestDetailsType.tx_hash)
}
inline ::std::string* TxRequest_TxRequestDetailsType::mutable_tx_hash() {
  set_has_tx_hash();
  if (tx_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tx_hash_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TxRequest.TxRequestDetailsType.tx_hash)
  return tx_hash_;
}
inline ::std::string* TxRequest_TxRequestDetailsType::release_tx_hash() {
  clear_has_tx_hash();
  if (tx_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tx_hash_;
    tx_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TxRequest_TxRequestDetailsType::set_allocated_tx_hash(::std::string* tx_hash) {
  if (tx_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tx_hash_;
  }
  if (tx_hash) {
    set_has_tx_hash();
    tx_hash_ = tx_hash;
  } else {
    clear_has_tx_hash();
    tx_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TxRequest.TxRequestDetailsType.tx_hash)
}

// optional uint32 extra_data_len = 3;
inline bool TxRequest_TxRequestDetailsType::has_extra_data_len() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TxRequest_TxRequestDetailsType::set_has_extra_data_len() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TxRequest_TxRequestDetailsType::clear_has_extra_data_len() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TxRequest_TxRequestDetailsType::clear_extra_data_len() {
  extra_data_len_ = 0u;
  clear_has_extra_data_len();
}
inline ::google::protobuf::uint32 TxRequest_TxRequestDetailsType::extra_data_len() const {
  // @@protoc_insertion_point(field_get:TxRequest.TxRequestDetailsType.extra_data_len)
  return extra_data_len_;
}
inline void TxRequest_TxRequestDetailsType::set_extra_data_len(::google::protobuf::uint32 value) {
  set_has_extra_data_len();
  extra_data_len_ = value;
  // @@protoc_insertion_point(field_set:TxRequest.TxRequestDetailsType.extra_data_len)
}

// optional uint32 extra_data_offset = 4;
inline bool TxRequest_TxRequestDetailsType::has_extra_data_offset() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TxRequest_TxRequestDetailsType::set_has_extra_data_offset() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TxRequest_TxRequestDetailsType::clear_has_extra_data_offset() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TxRequest_TxRequestDetailsType::clear_extra_data_offset() {
  extra_data_offset_ = 0u;
  clear_has_extra_data_offset();
}
inline ::google::protobuf::uint32 TxRequest_TxRequestDetailsType::extra_data_offset() const {
  // @@protoc_insertion_point(field_get:TxRequest.TxRequestDetailsType.extra_data_offset)
  return extra_data_offset_;
}
inline void TxRequest_TxRequestDetailsType::set_extra_data_offset(::google::protobuf::uint32 value) {
  set_has_extra_data_offset();
  extra_data_offset_ = value;
  // @@protoc_insertion_point(field_set:TxRequest.TxRequestDetailsType.extra_data_offset)
}

// -------------------------------------------------------------------

// TxRequest_TxRequestSerializedType

// optional uint32 signature_index = 1;
inline bool TxRequest_TxRequestSerializedType::has_signature_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TxRequest_TxRequestSerializedType::set_has_signature_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TxRequest_TxRequestSerializedType::clear_has_signature_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TxRequest_TxRequestSerializedType::clear_signature_index() {
  signature_index_ = 0u;
  clear_has_signature_index();
}
inline ::google::protobuf::uint32 TxRequest_TxRequestSerializedType::signature_index() const {
  // @@protoc_insertion_point(field_get:TxRequest.TxRequestSerializedType.signature_index)
  return signature_index_;
}
inline void TxRequest_TxRequestSerializedType::set_signature_index(::google::protobuf::uint32 value) {
  set_has_signature_index();
  signature_index_ = value;
  // @@protoc_insertion_point(field_set:TxRequest.TxRequestSerializedType.signature_index)
}

// optional bytes signature = 2;
inline bool TxRequest_TxRequestSerializedType::has_signature() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TxRequest_TxRequestSerializedType::set_has_signature() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TxRequest_TxRequestSerializedType::clear_has_signature() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TxRequest_TxRequestSerializedType::clear_signature() {
  if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_->clear();
  }
  clear_has_signature();
}
inline const ::std::string& TxRequest_TxRequestSerializedType::signature() const {
  // @@protoc_insertion_point(field_get:TxRequest.TxRequestSerializedType.signature)
  return *signature_;
}
inline void TxRequest_TxRequestSerializedType::set_signature(const ::std::string& value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
  // @@protoc_insertion_point(field_set:TxRequest.TxRequestSerializedType.signature)
}
inline void TxRequest_TxRequestSerializedType::set_signature(const char* value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
  // @@protoc_insertion_point(field_set_char:TxRequest.TxRequestSerializedType.signature)
}
inline void TxRequest_TxRequestSerializedType::set_signature(const void* value, size_t size) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TxRequest.TxRequestSerializedType.signature)
}
inline ::std::string* TxRequest_TxRequestSerializedType::mutable_signature() {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TxRequest.TxRequestSerializedType.signature)
  return signature_;
}
inline ::std::string* TxRequest_TxRequestSerializedType::release_signature() {
  clear_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = signature_;
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TxRequest_TxRequestSerializedType::set_allocated_signature(::std::string* signature) {
  if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete signature_;
  }
  if (signature) {
    set_has_signature();
    signature_ = signature;
  } else {
    clear_has_signature();
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TxRequest.TxRequestSerializedType.signature)
}

// optional bytes serialized_tx = 3;
inline bool TxRequest_TxRequestSerializedType::has_serialized_tx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TxRequest_TxRequestSerializedType::set_has_serialized_tx() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TxRequest_TxRequestSerializedType::clear_has_serialized_tx() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TxRequest_TxRequestSerializedType::clear_serialized_tx() {
  if (serialized_tx_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serialized_tx_->clear();
  }
  clear_has_serialized_tx();
}
inline const ::std::string& TxRequest_TxRequestSerializedType::serialized_tx() const {
  // @@protoc_insertion_point(field_get:TxRequest.TxRequestSerializedType.serialized_tx)
  return *serialized_tx_;
}
inline void TxRequest_TxRequestSerializedType::set_serialized_tx(const ::std::string& value) {
  set_has_serialized_tx();
  if (serialized_tx_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serialized_tx_ = new ::std::string;
  }
  serialized_tx_->assign(value);
  // @@protoc_insertion_point(field_set:TxRequest.TxRequestSerializedType.serialized_tx)
}
inline void TxRequest_TxRequestSerializedType::set_serialized_tx(const char* value) {
  set_has_serialized_tx();
  if (serialized_tx_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serialized_tx_ = new ::std::string;
  }
  serialized_tx_->assign(value);
  // @@protoc_insertion_point(field_set_char:TxRequest.TxRequestSerializedType.serialized_tx)
}
inline void TxRequest_TxRequestSerializedType::set_serialized_tx(const void* value, size_t size) {
  set_has_serialized_tx();
  if (serialized_tx_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serialized_tx_ = new ::std::string;
  }
  serialized_tx_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TxRequest.TxRequestSerializedType.serialized_tx)
}
inline ::std::string* TxRequest_TxRequestSerializedType::mutable_serialized_tx() {
  set_has_serialized_tx();
  if (serialized_tx_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serialized_tx_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TxRequest.TxRequestSerializedType.serialized_tx)
  return serialized_tx_;
}
inline ::std::string* TxRequest_TxRequestSerializedType::release_serialized_tx() {
  clear_has_serialized_tx();
  if (serialized_tx_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = serialized_tx_;
    serialized_tx_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TxRequest_TxRequestSerializedType::set_allocated_serialized_tx(::std::string* serialized_tx) {
  if (serialized_tx_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete serialized_tx_;
  }
  if (serialized_tx) {
    set_has_serialized_tx();
    serialized_tx_ = serialized_tx;
  } else {
    clear_has_serialized_tx();
    serialized_tx_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TxRequest.TxRequestSerializedType.serialized_tx)
}

// -------------------------------------------------------------------

// TxRequest

// optional .TxRequest.RequestType request_type = 1;
inline bool TxRequest::has_request_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TxRequest::set_has_request_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TxRequest::clear_has_request_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TxRequest::clear_request_type() {
  request_type_ = 0;
  clear_has_request_type();
}
inline ::TxRequest_RequestType TxRequest::request_type() const {
  // @@protoc_insertion_point(field_get:TxRequest.request_type)
  return static_cast< ::TxRequest_RequestType >(request_type_);
}
inline void TxRequest::set_request_type(::TxRequest_RequestType value) {
  assert(::TxRequest_RequestType_IsValid(value));
  set_has_request_type();
  request_type_ = value;
  // @@protoc_insertion_point(field_set:TxRequest.request_type)
}

// optional .TxRequest.TxRequestDetailsType details = 2;
inline bool TxRequest::has_details() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TxRequest::set_has_details() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TxRequest::clear_has_details() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TxRequest::clear_details() {
  if (details_ != NULL) details_->::TxRequest_TxRequestDetailsType::Clear();
  clear_has_details();
}
inline const ::TxRequest_TxRequestDetailsType& TxRequest::details() const {
  // @@protoc_insertion_point(field_get:TxRequest.details)
  return details_ != NULL ? *details_ : *default_instance_->details_;
}
inline ::TxRequest_TxRequestDetailsType* TxRequest::mutable_details() {
  set_has_details();
  if (details_ == NULL) details_ = new ::TxRequest_TxRequestDetailsType;
  // @@protoc_insertion_point(field_mutable:TxRequest.details)
  return details_;
}
inline ::TxRequest_TxRequestDetailsType* TxRequest::release_details() {
  clear_has_details();
  ::TxRequest_TxRequestDetailsType* temp = details_;
  details_ = NULL;
  return temp;
}
inline void TxRequest::set_allocated_details(::TxRequest_TxRequestDetailsType* details) {
  delete details_;
  details_ = details;
  if (details) {
    set_has_details();
  } else {
    clear_has_details();
  }
  // @@protoc_insertion_point(field_set_allocated:TxRequest.details)
}

// optional .TxRequest.TxRequestSerializedType serialized = 3;
inline bool TxRequest::has_serialized() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TxRequest::set_has_serialized() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TxRequest::clear_has_serialized() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TxRequest::clear_serialized() {
  if (serialized_ != NULL) serialized_->::TxRequest_TxRequestSerializedType::Clear();
  clear_has_serialized();
}
inline const ::TxRequest_TxRequestSerializedType& TxRequest::serialized() const {
  // @@protoc_insertion_point(field_get:TxRequest.serialized)
  return serialized_ != NULL ? *serialized_ : *default_instance_->serialized_;
}
inline ::TxRequest_TxRequestSerializedType* TxRequest::mutable_serialized() {
  set_has_serialized();
  if (serialized_ == NULL) serialized_ = new ::TxRequest_TxRequestSerializedType;
  // @@protoc_insertion_point(field_mutable:TxRequest.serialized)
  return serialized_;
}
inline ::TxRequest_TxRequestSerializedType* TxRequest::release_serialized() {
  clear_has_serialized();
  ::TxRequest_TxRequestSerializedType* temp = serialized_;
  serialized_ = NULL;
  return temp;
}
inline void TxRequest::set_allocated_serialized(::TxRequest_TxRequestSerializedType* serialized) {
  delete serialized_;
  serialized_ = serialized;
  if (serialized) {
    set_has_serialized();
  } else {
    clear_has_serialized();
  }
  // @@protoc_insertion_point(field_set_allocated:TxRequest.serialized)
}

// -------------------------------------------------------------------

// TxAck_TransactionType_TxInputType

// repeated uint32 address_n = 1;
inline int TxAck_TransactionType_TxInputType::address_n_size() const {
  return address_n_.size();
}
inline void TxAck_TransactionType_TxInputType::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 TxAck_TransactionType_TxInputType::address_n(int index) const {
  // @@protoc_insertion_point(field_get:TxAck.TransactionType.TxInputType.address_n)
  return address_n_.Get(index);
}
inline void TxAck_TransactionType_TxInputType::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:TxAck.TransactionType.TxInputType.address_n)
}
inline void TxAck_TransactionType_TxInputType::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:TxAck.TransactionType.TxInputType.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TxAck_TransactionType_TxInputType::address_n() const {
  // @@protoc_insertion_point(field_list:TxAck.TransactionType.TxInputType.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TxAck_TransactionType_TxInputType::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:TxAck.TransactionType.TxInputType.address_n)
  return &address_n_;
}

// required bytes prev_hash = 2;
inline bool TxAck_TransactionType_TxInputType::has_prev_hash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TxAck_TransactionType_TxInputType::set_has_prev_hash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TxAck_TransactionType_TxInputType::clear_has_prev_hash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TxAck_TransactionType_TxInputType::clear_prev_hash() {
  if (prev_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    prev_hash_->clear();
  }
  clear_has_prev_hash();
}
inline const ::std::string& TxAck_TransactionType_TxInputType::prev_hash() const {
  // @@protoc_insertion_point(field_get:TxAck.TransactionType.TxInputType.prev_hash)
  return *prev_hash_;
}
inline void TxAck_TransactionType_TxInputType::set_prev_hash(const ::std::string& value) {
  set_has_prev_hash();
  if (prev_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    prev_hash_ = new ::std::string;
  }
  prev_hash_->assign(value);
  // @@protoc_insertion_point(field_set:TxAck.TransactionType.TxInputType.prev_hash)
}
inline void TxAck_TransactionType_TxInputType::set_prev_hash(const char* value) {
  set_has_prev_hash();
  if (prev_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    prev_hash_ = new ::std::string;
  }
  prev_hash_->assign(value);
  // @@protoc_insertion_point(field_set_char:TxAck.TransactionType.TxInputType.prev_hash)
}
inline void TxAck_TransactionType_TxInputType::set_prev_hash(const void* value, size_t size) {
  set_has_prev_hash();
  if (prev_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    prev_hash_ = new ::std::string;
  }
  prev_hash_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TxAck.TransactionType.TxInputType.prev_hash)
}
inline ::std::string* TxAck_TransactionType_TxInputType::mutable_prev_hash() {
  set_has_prev_hash();
  if (prev_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    prev_hash_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TxAck.TransactionType.TxInputType.prev_hash)
  return prev_hash_;
}
inline ::std::string* TxAck_TransactionType_TxInputType::release_prev_hash() {
  clear_has_prev_hash();
  if (prev_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = prev_hash_;
    prev_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TxAck_TransactionType_TxInputType::set_allocated_prev_hash(::std::string* prev_hash) {
  if (prev_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete prev_hash_;
  }
  if (prev_hash) {
    set_has_prev_hash();
    prev_hash_ = prev_hash;
  } else {
    clear_has_prev_hash();
    prev_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TxAck.TransactionType.TxInputType.prev_hash)
}

// required uint32 prev_index = 3;
inline bool TxAck_TransactionType_TxInputType::has_prev_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TxAck_TransactionType_TxInputType::set_has_prev_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TxAck_TransactionType_TxInputType::clear_has_prev_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TxAck_TransactionType_TxInputType::clear_prev_index() {
  prev_index_ = 0u;
  clear_has_prev_index();
}
inline ::google::protobuf::uint32 TxAck_TransactionType_TxInputType::prev_index() const {
  // @@protoc_insertion_point(field_get:TxAck.TransactionType.TxInputType.prev_index)
  return prev_index_;
}
inline void TxAck_TransactionType_TxInputType::set_prev_index(::google::protobuf::uint32 value) {
  set_has_prev_index();
  prev_index_ = value;
  // @@protoc_insertion_point(field_set:TxAck.TransactionType.TxInputType.prev_index)
}

// optional bytes script_sig = 4;
inline bool TxAck_TransactionType_TxInputType::has_script_sig() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TxAck_TransactionType_TxInputType::set_has_script_sig() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TxAck_TransactionType_TxInputType::clear_has_script_sig() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TxAck_TransactionType_TxInputType::clear_script_sig() {
  if (script_sig_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    script_sig_->clear();
  }
  clear_has_script_sig();
}
inline const ::std::string& TxAck_TransactionType_TxInputType::script_sig() const {
  // @@protoc_insertion_point(field_get:TxAck.TransactionType.TxInputType.script_sig)
  return *script_sig_;
}
inline void TxAck_TransactionType_TxInputType::set_script_sig(const ::std::string& value) {
  set_has_script_sig();
  if (script_sig_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    script_sig_ = new ::std::string;
  }
  script_sig_->assign(value);
  // @@protoc_insertion_point(field_set:TxAck.TransactionType.TxInputType.script_sig)
}
inline void TxAck_TransactionType_TxInputType::set_script_sig(const char* value) {
  set_has_script_sig();
  if (script_sig_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    script_sig_ = new ::std::string;
  }
  script_sig_->assign(value);
  // @@protoc_insertion_point(field_set_char:TxAck.TransactionType.TxInputType.script_sig)
}
inline void TxAck_TransactionType_TxInputType::set_script_sig(const void* value, size_t size) {
  set_has_script_sig();
  if (script_sig_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    script_sig_ = new ::std::string;
  }
  script_sig_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TxAck.TransactionType.TxInputType.script_sig)
}
inline ::std::string* TxAck_TransactionType_TxInputType::mutable_script_sig() {
  set_has_script_sig();
  if (script_sig_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    script_sig_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TxAck.TransactionType.TxInputType.script_sig)
  return script_sig_;
}
inline ::std::string* TxAck_TransactionType_TxInputType::release_script_sig() {
  clear_has_script_sig();
  if (script_sig_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = script_sig_;
    script_sig_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TxAck_TransactionType_TxInputType::set_allocated_script_sig(::std::string* script_sig) {
  if (script_sig_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete script_sig_;
  }
  if (script_sig) {
    set_has_script_sig();
    script_sig_ = script_sig;
  } else {
    clear_has_script_sig();
    script_sig_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TxAck.TransactionType.TxInputType.script_sig)
}

// optional uint32 sequence = 5 [default = 4294967295];
inline bool TxAck_TransactionType_TxInputType::has_sequence() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TxAck_TransactionType_TxInputType::set_has_sequence() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TxAck_TransactionType_TxInputType::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TxAck_TransactionType_TxInputType::clear_sequence() {
  sequence_ = 4294967295u;
  clear_has_sequence();
}
inline ::google::protobuf::uint32 TxAck_TransactionType_TxInputType::sequence() const {
  // @@protoc_insertion_point(field_get:TxAck.TransactionType.TxInputType.sequence)
  return sequence_;
}
inline void TxAck_TransactionType_TxInputType::set_sequence(::google::protobuf::uint32 value) {
  set_has_sequence();
  sequence_ = value;
  // @@protoc_insertion_point(field_set:TxAck.TransactionType.TxInputType.sequence)
}

// optional .InputScriptType script_type = 6 [default = SPENDADDRESS];
inline bool TxAck_TransactionType_TxInputType::has_script_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TxAck_TransactionType_TxInputType::set_has_script_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TxAck_TransactionType_TxInputType::clear_has_script_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TxAck_TransactionType_TxInputType::clear_script_type() {
  script_type_ = 0;
  clear_has_script_type();
}
inline ::InputScriptType TxAck_TransactionType_TxInputType::script_type() const {
  // @@protoc_insertion_point(field_get:TxAck.TransactionType.TxInputType.script_type)
  return static_cast< ::InputScriptType >(script_type_);
}
inline void TxAck_TransactionType_TxInputType::set_script_type(::InputScriptType value) {
  assert(::InputScriptType_IsValid(value));
  set_has_script_type();
  script_type_ = value;
  // @@protoc_insertion_point(field_set:TxAck.TransactionType.TxInputType.script_type)
}

// optional .MultisigRedeemScriptType multisig = 7;
inline bool TxAck_TransactionType_TxInputType::has_multisig() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TxAck_TransactionType_TxInputType::set_has_multisig() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TxAck_TransactionType_TxInputType::clear_has_multisig() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TxAck_TransactionType_TxInputType::clear_multisig() {
  if (multisig_ != NULL) multisig_->::MultisigRedeemScriptType::Clear();
  clear_has_multisig();
}
inline const ::MultisigRedeemScriptType& TxAck_TransactionType_TxInputType::multisig() const {
  // @@protoc_insertion_point(field_get:TxAck.TransactionType.TxInputType.multisig)
  return multisig_ != NULL ? *multisig_ : *default_instance_->multisig_;
}
inline ::MultisigRedeemScriptType* TxAck_TransactionType_TxInputType::mutable_multisig() {
  set_has_multisig();
  if (multisig_ == NULL) multisig_ = new ::MultisigRedeemScriptType;
  // @@protoc_insertion_point(field_mutable:TxAck.TransactionType.TxInputType.multisig)
  return multisig_;
}
inline ::MultisigRedeemScriptType* TxAck_TransactionType_TxInputType::release_multisig() {
  clear_has_multisig();
  ::MultisigRedeemScriptType* temp = multisig_;
  multisig_ = NULL;
  return temp;
}
inline void TxAck_TransactionType_TxInputType::set_allocated_multisig(::MultisigRedeemScriptType* multisig) {
  delete multisig_;
  multisig_ = multisig;
  if (multisig) {
    set_has_multisig();
  } else {
    clear_has_multisig();
  }
  // @@protoc_insertion_point(field_set_allocated:TxAck.TransactionType.TxInputType.multisig)
}

// optional uint64 amount = 8;
inline bool TxAck_TransactionType_TxInputType::has_amount() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TxAck_TransactionType_TxInputType::set_has_amount() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TxAck_TransactionType_TxInputType::clear_has_amount() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TxAck_TransactionType_TxInputType::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 TxAck_TransactionType_TxInputType::amount() const {
  // @@protoc_insertion_point(field_get:TxAck.TransactionType.TxInputType.amount)
  return amount_;
}
inline void TxAck_TransactionType_TxInputType::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
  // @@protoc_insertion_point(field_set:TxAck.TransactionType.TxInputType.amount)
}

// optional uint32 decred_tree = 9;
inline bool TxAck_TransactionType_TxInputType::has_decred_tree() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TxAck_TransactionType_TxInputType::set_has_decred_tree() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TxAck_TransactionType_TxInputType::clear_has_decred_tree() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TxAck_TransactionType_TxInputType::clear_decred_tree() {
  decred_tree_ = 0u;
  clear_has_decred_tree();
}
inline ::google::protobuf::uint32 TxAck_TransactionType_TxInputType::decred_tree() const {
  // @@protoc_insertion_point(field_get:TxAck.TransactionType.TxInputType.decred_tree)
  return decred_tree_;
}
inline void TxAck_TransactionType_TxInputType::set_decred_tree(::google::protobuf::uint32 value) {
  set_has_decred_tree();
  decred_tree_ = value;
  // @@protoc_insertion_point(field_set:TxAck.TransactionType.TxInputType.decred_tree)
}

// optional uint32 decred_script_version = 10;
inline bool TxAck_TransactionType_TxInputType::has_decred_script_version() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TxAck_TransactionType_TxInputType::set_has_decred_script_version() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TxAck_TransactionType_TxInputType::clear_has_decred_script_version() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TxAck_TransactionType_TxInputType::clear_decred_script_version() {
  decred_script_version_ = 0u;
  clear_has_decred_script_version();
}
inline ::google::protobuf::uint32 TxAck_TransactionType_TxInputType::decred_script_version() const {
  // @@protoc_insertion_point(field_get:TxAck.TransactionType.TxInputType.decred_script_version)
  return decred_script_version_;
}
inline void TxAck_TransactionType_TxInputType::set_decred_script_version(::google::protobuf::uint32 value) {
  set_has_decred_script_version();
  decred_script_version_ = value;
  // @@protoc_insertion_point(field_set:TxAck.TransactionType.TxInputType.decred_script_version)
}

// optional bytes prev_block_hash_bip115 = 11;
inline bool TxAck_TransactionType_TxInputType::has_prev_block_hash_bip115() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TxAck_TransactionType_TxInputType::set_has_prev_block_hash_bip115() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TxAck_TransactionType_TxInputType::clear_has_prev_block_hash_bip115() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TxAck_TransactionType_TxInputType::clear_prev_block_hash_bip115() {
  if (prev_block_hash_bip115_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    prev_block_hash_bip115_->clear();
  }
  clear_has_prev_block_hash_bip115();
}
inline const ::std::string& TxAck_TransactionType_TxInputType::prev_block_hash_bip115() const {
  // @@protoc_insertion_point(field_get:TxAck.TransactionType.TxInputType.prev_block_hash_bip115)
  return *prev_block_hash_bip115_;
}
inline void TxAck_TransactionType_TxInputType::set_prev_block_hash_bip115(const ::std::string& value) {
  set_has_prev_block_hash_bip115();
  if (prev_block_hash_bip115_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    prev_block_hash_bip115_ = new ::std::string;
  }
  prev_block_hash_bip115_->assign(value);
  // @@protoc_insertion_point(field_set:TxAck.TransactionType.TxInputType.prev_block_hash_bip115)
}
inline void TxAck_TransactionType_TxInputType::set_prev_block_hash_bip115(const char* value) {
  set_has_prev_block_hash_bip115();
  if (prev_block_hash_bip115_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    prev_block_hash_bip115_ = new ::std::string;
  }
  prev_block_hash_bip115_->assign(value);
  // @@protoc_insertion_point(field_set_char:TxAck.TransactionType.TxInputType.prev_block_hash_bip115)
}
inline void TxAck_TransactionType_TxInputType::set_prev_block_hash_bip115(const void* value, size_t size) {
  set_has_prev_block_hash_bip115();
  if (prev_block_hash_bip115_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    prev_block_hash_bip115_ = new ::std::string;
  }
  prev_block_hash_bip115_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TxAck.TransactionType.TxInputType.prev_block_hash_bip115)
}
inline ::std::string* TxAck_TransactionType_TxInputType::mutable_prev_block_hash_bip115() {
  set_has_prev_block_hash_bip115();
  if (prev_block_hash_bip115_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    prev_block_hash_bip115_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TxAck.TransactionType.TxInputType.prev_block_hash_bip115)
  return prev_block_hash_bip115_;
}
inline ::std::string* TxAck_TransactionType_TxInputType::release_prev_block_hash_bip115() {
  clear_has_prev_block_hash_bip115();
  if (prev_block_hash_bip115_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = prev_block_hash_bip115_;
    prev_block_hash_bip115_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TxAck_TransactionType_TxInputType::set_allocated_prev_block_hash_bip115(::std::string* prev_block_hash_bip115) {
  if (prev_block_hash_bip115_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete prev_block_hash_bip115_;
  }
  if (prev_block_hash_bip115) {
    set_has_prev_block_hash_bip115();
    prev_block_hash_bip115_ = prev_block_hash_bip115;
  } else {
    clear_has_prev_block_hash_bip115();
    prev_block_hash_bip115_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TxAck.TransactionType.TxInputType.prev_block_hash_bip115)
}

// optional uint32 prev_block_height_bip115 = 12;
inline bool TxAck_TransactionType_TxInputType::has_prev_block_height_bip115() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TxAck_TransactionType_TxInputType::set_has_prev_block_height_bip115() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TxAck_TransactionType_TxInputType::clear_has_prev_block_height_bip115() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TxAck_TransactionType_TxInputType::clear_prev_block_height_bip115() {
  prev_block_height_bip115_ = 0u;
  clear_has_prev_block_height_bip115();
}
inline ::google::protobuf::uint32 TxAck_TransactionType_TxInputType::prev_block_height_bip115() const {
  // @@protoc_insertion_point(field_get:TxAck.TransactionType.TxInputType.prev_block_height_bip115)
  return prev_block_height_bip115_;
}
inline void TxAck_TransactionType_TxInputType::set_prev_block_height_bip115(::google::protobuf::uint32 value) {
  set_has_prev_block_height_bip115();
  prev_block_height_bip115_ = value;
  // @@protoc_insertion_point(field_set:TxAck.TransactionType.TxInputType.prev_block_height_bip115)
}

// -------------------------------------------------------------------

// TxAck_TransactionType_TxOutputBinType

// required uint64 amount = 1;
inline bool TxAck_TransactionType_TxOutputBinType::has_amount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TxAck_TransactionType_TxOutputBinType::set_has_amount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TxAck_TransactionType_TxOutputBinType::clear_has_amount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TxAck_TransactionType_TxOutputBinType::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 TxAck_TransactionType_TxOutputBinType::amount() const {
  // @@protoc_insertion_point(field_get:TxAck.TransactionType.TxOutputBinType.amount)
  return amount_;
}
inline void TxAck_TransactionType_TxOutputBinType::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
  // @@protoc_insertion_point(field_set:TxAck.TransactionType.TxOutputBinType.amount)
}

// required bytes script_pubkey = 2;
inline bool TxAck_TransactionType_TxOutputBinType::has_script_pubkey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TxAck_TransactionType_TxOutputBinType::set_has_script_pubkey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TxAck_TransactionType_TxOutputBinType::clear_has_script_pubkey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TxAck_TransactionType_TxOutputBinType::clear_script_pubkey() {
  if (script_pubkey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    script_pubkey_->clear();
  }
  clear_has_script_pubkey();
}
inline const ::std::string& TxAck_TransactionType_TxOutputBinType::script_pubkey() const {
  // @@protoc_insertion_point(field_get:TxAck.TransactionType.TxOutputBinType.script_pubkey)
  return *script_pubkey_;
}
inline void TxAck_TransactionType_TxOutputBinType::set_script_pubkey(const ::std::string& value) {
  set_has_script_pubkey();
  if (script_pubkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    script_pubkey_ = new ::std::string;
  }
  script_pubkey_->assign(value);
  // @@protoc_insertion_point(field_set:TxAck.TransactionType.TxOutputBinType.script_pubkey)
}
inline void TxAck_TransactionType_TxOutputBinType::set_script_pubkey(const char* value) {
  set_has_script_pubkey();
  if (script_pubkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    script_pubkey_ = new ::std::string;
  }
  script_pubkey_->assign(value);
  // @@protoc_insertion_point(field_set_char:TxAck.TransactionType.TxOutputBinType.script_pubkey)
}
inline void TxAck_TransactionType_TxOutputBinType::set_script_pubkey(const void* value, size_t size) {
  set_has_script_pubkey();
  if (script_pubkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    script_pubkey_ = new ::std::string;
  }
  script_pubkey_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TxAck.TransactionType.TxOutputBinType.script_pubkey)
}
inline ::std::string* TxAck_TransactionType_TxOutputBinType::mutable_script_pubkey() {
  set_has_script_pubkey();
  if (script_pubkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    script_pubkey_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TxAck.TransactionType.TxOutputBinType.script_pubkey)
  return script_pubkey_;
}
inline ::std::string* TxAck_TransactionType_TxOutputBinType::release_script_pubkey() {
  clear_has_script_pubkey();
  if (script_pubkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = script_pubkey_;
    script_pubkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TxAck_TransactionType_TxOutputBinType::set_allocated_script_pubkey(::std::string* script_pubkey) {
  if (script_pubkey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete script_pubkey_;
  }
  if (script_pubkey) {
    set_has_script_pubkey();
    script_pubkey_ = script_pubkey;
  } else {
    clear_has_script_pubkey();
    script_pubkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TxAck.TransactionType.TxOutputBinType.script_pubkey)
}

// optional uint32 decred_script_version = 3;
inline bool TxAck_TransactionType_TxOutputBinType::has_decred_script_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TxAck_TransactionType_TxOutputBinType::set_has_decred_script_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TxAck_TransactionType_TxOutputBinType::clear_has_decred_script_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TxAck_TransactionType_TxOutputBinType::clear_decred_script_version() {
  decred_script_version_ = 0u;
  clear_has_decred_script_version();
}
inline ::google::protobuf::uint32 TxAck_TransactionType_TxOutputBinType::decred_script_version() const {
  // @@protoc_insertion_point(field_get:TxAck.TransactionType.TxOutputBinType.decred_script_version)
  return decred_script_version_;
}
inline void TxAck_TransactionType_TxOutputBinType::set_decred_script_version(::google::protobuf::uint32 value) {
  set_has_decred_script_version();
  decred_script_version_ = value;
  // @@protoc_insertion_point(field_set:TxAck.TransactionType.TxOutputBinType.decred_script_version)
}

// -------------------------------------------------------------------

// TxAck_TransactionType_TxOutputType

// optional string address = 1;
inline bool TxAck_TransactionType_TxOutputType::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TxAck_TransactionType_TxOutputType::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TxAck_TransactionType_TxOutputType::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TxAck_TransactionType_TxOutputType::clear_address() {
  if (address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& TxAck_TransactionType_TxOutputType::address() const {
  // @@protoc_insertion_point(field_get:TxAck.TransactionType.TxOutputType.address)
  return *address_;
}
inline void TxAck_TransactionType_TxOutputType::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  address_->assign(value);
  // @@protoc_insertion_point(field_set:TxAck.TransactionType.TxOutputType.address)
}
inline void TxAck_TransactionType_TxOutputType::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  address_->assign(value);
  // @@protoc_insertion_point(field_set_char:TxAck.TransactionType.TxOutputType.address)
}
inline void TxAck_TransactionType_TxOutputType::set_address(const char* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TxAck.TransactionType.TxOutputType.address)
}
inline ::std::string* TxAck_TransactionType_TxOutputType::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TxAck.TransactionType.TxOutputType.address)
  return address_;
}
inline ::std::string* TxAck_TransactionType_TxOutputType::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TxAck_TransactionType_TxOutputType::set_allocated_address(::std::string* address) {
  if (address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete address_;
  }
  if (address) {
    set_has_address();
    address_ = address;
  } else {
    clear_has_address();
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TxAck.TransactionType.TxOutputType.address)
}

// repeated uint32 address_n = 2;
inline int TxAck_TransactionType_TxOutputType::address_n_size() const {
  return address_n_.size();
}
inline void TxAck_TransactionType_TxOutputType::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 TxAck_TransactionType_TxOutputType::address_n(int index) const {
  // @@protoc_insertion_point(field_get:TxAck.TransactionType.TxOutputType.address_n)
  return address_n_.Get(index);
}
inline void TxAck_TransactionType_TxOutputType::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:TxAck.TransactionType.TxOutputType.address_n)
}
inline void TxAck_TransactionType_TxOutputType::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:TxAck.TransactionType.TxOutputType.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TxAck_TransactionType_TxOutputType::address_n() const {
  // @@protoc_insertion_point(field_list:TxAck.TransactionType.TxOutputType.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TxAck_TransactionType_TxOutputType::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:TxAck.TransactionType.TxOutputType.address_n)
  return &address_n_;
}

// required uint64 amount = 3;
inline bool TxAck_TransactionType_TxOutputType::has_amount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TxAck_TransactionType_TxOutputType::set_has_amount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TxAck_TransactionType_TxOutputType::clear_has_amount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TxAck_TransactionType_TxOutputType::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 TxAck_TransactionType_TxOutputType::amount() const {
  // @@protoc_insertion_point(field_get:TxAck.TransactionType.TxOutputType.amount)
  return amount_;
}
inline void TxAck_TransactionType_TxOutputType::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
  // @@protoc_insertion_point(field_set:TxAck.TransactionType.TxOutputType.amount)
}

// required .TxAck.TransactionType.TxOutputType.OutputScriptType script_type = 4;
inline bool TxAck_TransactionType_TxOutputType::has_script_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TxAck_TransactionType_TxOutputType::set_has_script_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TxAck_TransactionType_TxOutputType::clear_has_script_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TxAck_TransactionType_TxOutputType::clear_script_type() {
  script_type_ = 0;
  clear_has_script_type();
}
inline ::TxAck_TransactionType_TxOutputType_OutputScriptType TxAck_TransactionType_TxOutputType::script_type() const {
  // @@protoc_insertion_point(field_get:TxAck.TransactionType.TxOutputType.script_type)
  return static_cast< ::TxAck_TransactionType_TxOutputType_OutputScriptType >(script_type_);
}
inline void TxAck_TransactionType_TxOutputType::set_script_type(::TxAck_TransactionType_TxOutputType_OutputScriptType value) {
  assert(::TxAck_TransactionType_TxOutputType_OutputScriptType_IsValid(value));
  set_has_script_type();
  script_type_ = value;
  // @@protoc_insertion_point(field_set:TxAck.TransactionType.TxOutputType.script_type)
}

// optional .MultisigRedeemScriptType multisig = 5;
inline bool TxAck_TransactionType_TxOutputType::has_multisig() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TxAck_TransactionType_TxOutputType::set_has_multisig() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TxAck_TransactionType_TxOutputType::clear_has_multisig() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TxAck_TransactionType_TxOutputType::clear_multisig() {
  if (multisig_ != NULL) multisig_->::MultisigRedeemScriptType::Clear();
  clear_has_multisig();
}
inline const ::MultisigRedeemScriptType& TxAck_TransactionType_TxOutputType::multisig() const {
  // @@protoc_insertion_point(field_get:TxAck.TransactionType.TxOutputType.multisig)
  return multisig_ != NULL ? *multisig_ : *default_instance_->multisig_;
}
inline ::MultisigRedeemScriptType* TxAck_TransactionType_TxOutputType::mutable_multisig() {
  set_has_multisig();
  if (multisig_ == NULL) multisig_ = new ::MultisigRedeemScriptType;
  // @@protoc_insertion_point(field_mutable:TxAck.TransactionType.TxOutputType.multisig)
  return multisig_;
}
inline ::MultisigRedeemScriptType* TxAck_TransactionType_TxOutputType::release_multisig() {
  clear_has_multisig();
  ::MultisigRedeemScriptType* temp = multisig_;
  multisig_ = NULL;
  return temp;
}
inline void TxAck_TransactionType_TxOutputType::set_allocated_multisig(::MultisigRedeemScriptType* multisig) {
  delete multisig_;
  multisig_ = multisig;
  if (multisig) {
    set_has_multisig();
  } else {
    clear_has_multisig();
  }
  // @@protoc_insertion_point(field_set_allocated:TxAck.TransactionType.TxOutputType.multisig)
}

// optional bytes op_return_data = 6;
inline bool TxAck_TransactionType_TxOutputType::has_op_return_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TxAck_TransactionType_TxOutputType::set_has_op_return_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TxAck_TransactionType_TxOutputType::clear_has_op_return_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TxAck_TransactionType_TxOutputType::clear_op_return_data() {
  if (op_return_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    op_return_data_->clear();
  }
  clear_has_op_return_data();
}
inline const ::std::string& TxAck_TransactionType_TxOutputType::op_return_data() const {
  // @@protoc_insertion_point(field_get:TxAck.TransactionType.TxOutputType.op_return_data)
  return *op_return_data_;
}
inline void TxAck_TransactionType_TxOutputType::set_op_return_data(const ::std::string& value) {
  set_has_op_return_data();
  if (op_return_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    op_return_data_ = new ::std::string;
  }
  op_return_data_->assign(value);
  // @@protoc_insertion_point(field_set:TxAck.TransactionType.TxOutputType.op_return_data)
}
inline void TxAck_TransactionType_TxOutputType::set_op_return_data(const char* value) {
  set_has_op_return_data();
  if (op_return_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    op_return_data_ = new ::std::string;
  }
  op_return_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:TxAck.TransactionType.TxOutputType.op_return_data)
}
inline void TxAck_TransactionType_TxOutputType::set_op_return_data(const void* value, size_t size) {
  set_has_op_return_data();
  if (op_return_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    op_return_data_ = new ::std::string;
  }
  op_return_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TxAck.TransactionType.TxOutputType.op_return_data)
}
inline ::std::string* TxAck_TransactionType_TxOutputType::mutable_op_return_data() {
  set_has_op_return_data();
  if (op_return_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    op_return_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TxAck.TransactionType.TxOutputType.op_return_data)
  return op_return_data_;
}
inline ::std::string* TxAck_TransactionType_TxOutputType::release_op_return_data() {
  clear_has_op_return_data();
  if (op_return_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = op_return_data_;
    op_return_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TxAck_TransactionType_TxOutputType::set_allocated_op_return_data(::std::string* op_return_data) {
  if (op_return_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete op_return_data_;
  }
  if (op_return_data) {
    set_has_op_return_data();
    op_return_data_ = op_return_data;
  } else {
    clear_has_op_return_data();
    op_return_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TxAck.TransactionType.TxOutputType.op_return_data)
}

// optional uint32 decred_script_version = 7;
inline bool TxAck_TransactionType_TxOutputType::has_decred_script_version() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TxAck_TransactionType_TxOutputType::set_has_decred_script_version() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TxAck_TransactionType_TxOutputType::clear_has_decred_script_version() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TxAck_TransactionType_TxOutputType::clear_decred_script_version() {
  decred_script_version_ = 0u;
  clear_has_decred_script_version();
}
inline ::google::protobuf::uint32 TxAck_TransactionType_TxOutputType::decred_script_version() const {
  // @@protoc_insertion_point(field_get:TxAck.TransactionType.TxOutputType.decred_script_version)
  return decred_script_version_;
}
inline void TxAck_TransactionType_TxOutputType::set_decred_script_version(::google::protobuf::uint32 value) {
  set_has_decred_script_version();
  decred_script_version_ = value;
  // @@protoc_insertion_point(field_set:TxAck.TransactionType.TxOutputType.decred_script_version)
}

// optional bytes block_hash_bip115 = 8;
inline bool TxAck_TransactionType_TxOutputType::has_block_hash_bip115() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TxAck_TransactionType_TxOutputType::set_has_block_hash_bip115() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TxAck_TransactionType_TxOutputType::clear_has_block_hash_bip115() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TxAck_TransactionType_TxOutputType::clear_block_hash_bip115() {
  if (block_hash_bip115_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    block_hash_bip115_->clear();
  }
  clear_has_block_hash_bip115();
}
inline const ::std::string& TxAck_TransactionType_TxOutputType::block_hash_bip115() const {
  // @@protoc_insertion_point(field_get:TxAck.TransactionType.TxOutputType.block_hash_bip115)
  return *block_hash_bip115_;
}
inline void TxAck_TransactionType_TxOutputType::set_block_hash_bip115(const ::std::string& value) {
  set_has_block_hash_bip115();
  if (block_hash_bip115_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    block_hash_bip115_ = new ::std::string;
  }
  block_hash_bip115_->assign(value);
  // @@protoc_insertion_point(field_set:TxAck.TransactionType.TxOutputType.block_hash_bip115)
}
inline void TxAck_TransactionType_TxOutputType::set_block_hash_bip115(const char* value) {
  set_has_block_hash_bip115();
  if (block_hash_bip115_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    block_hash_bip115_ = new ::std::string;
  }
  block_hash_bip115_->assign(value);
  // @@protoc_insertion_point(field_set_char:TxAck.TransactionType.TxOutputType.block_hash_bip115)
}
inline void TxAck_TransactionType_TxOutputType::set_block_hash_bip115(const void* value, size_t size) {
  set_has_block_hash_bip115();
  if (block_hash_bip115_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    block_hash_bip115_ = new ::std::string;
  }
  block_hash_bip115_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TxAck.TransactionType.TxOutputType.block_hash_bip115)
}
inline ::std::string* TxAck_TransactionType_TxOutputType::mutable_block_hash_bip115() {
  set_has_block_hash_bip115();
  if (block_hash_bip115_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    block_hash_bip115_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TxAck.TransactionType.TxOutputType.block_hash_bip115)
  return block_hash_bip115_;
}
inline ::std::string* TxAck_TransactionType_TxOutputType::release_block_hash_bip115() {
  clear_has_block_hash_bip115();
  if (block_hash_bip115_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = block_hash_bip115_;
    block_hash_bip115_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TxAck_TransactionType_TxOutputType::set_allocated_block_hash_bip115(::std::string* block_hash_bip115) {
  if (block_hash_bip115_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete block_hash_bip115_;
  }
  if (block_hash_bip115) {
    set_has_block_hash_bip115();
    block_hash_bip115_ = block_hash_bip115;
  } else {
    clear_has_block_hash_bip115();
    block_hash_bip115_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TxAck.TransactionType.TxOutputType.block_hash_bip115)
}

// optional uint32 block_height_bip115 = 9;
inline bool TxAck_TransactionType_TxOutputType::has_block_height_bip115() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TxAck_TransactionType_TxOutputType::set_has_block_height_bip115() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TxAck_TransactionType_TxOutputType::clear_has_block_height_bip115() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TxAck_TransactionType_TxOutputType::clear_block_height_bip115() {
  block_height_bip115_ = 0u;
  clear_has_block_height_bip115();
}
inline ::google::protobuf::uint32 TxAck_TransactionType_TxOutputType::block_height_bip115() const {
  // @@protoc_insertion_point(field_get:TxAck.TransactionType.TxOutputType.block_height_bip115)
  return block_height_bip115_;
}
inline void TxAck_TransactionType_TxOutputType::set_block_height_bip115(::google::protobuf::uint32 value) {
  set_has_block_height_bip115();
  block_height_bip115_ = value;
  // @@protoc_insertion_point(field_set:TxAck.TransactionType.TxOutputType.block_height_bip115)
}

// -------------------------------------------------------------------

// TxAck_TransactionType

// optional uint32 version = 1;
inline bool TxAck_TransactionType::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TxAck_TransactionType::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TxAck_TransactionType::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TxAck_TransactionType::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 TxAck_TransactionType::version() const {
  // @@protoc_insertion_point(field_get:TxAck.TransactionType.version)
  return version_;
}
inline void TxAck_TransactionType::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:TxAck.TransactionType.version)
}

// repeated .TxAck.TransactionType.TxInputType inputs = 2;
inline int TxAck_TransactionType::inputs_size() const {
  return inputs_.size();
}
inline void TxAck_TransactionType::clear_inputs() {
  inputs_.Clear();
}
inline const ::TxAck_TransactionType_TxInputType& TxAck_TransactionType::inputs(int index) const {
  // @@protoc_insertion_point(field_get:TxAck.TransactionType.inputs)
  return inputs_.Get(index);
}
inline ::TxAck_TransactionType_TxInputType* TxAck_TransactionType::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:TxAck.TransactionType.inputs)
  return inputs_.Mutable(index);
}
inline ::TxAck_TransactionType_TxInputType* TxAck_TransactionType::add_inputs() {
  // @@protoc_insertion_point(field_add:TxAck.TransactionType.inputs)
  return inputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TxAck_TransactionType_TxInputType >&
TxAck_TransactionType::inputs() const {
  // @@protoc_insertion_point(field_list:TxAck.TransactionType.inputs)
  return inputs_;
}
inline ::google::protobuf::RepeatedPtrField< ::TxAck_TransactionType_TxInputType >*
TxAck_TransactionType::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:TxAck.TransactionType.inputs)
  return &inputs_;
}

// repeated .TxAck.TransactionType.TxOutputBinType bin_outputs = 3;
inline int TxAck_TransactionType::bin_outputs_size() const {
  return bin_outputs_.size();
}
inline void TxAck_TransactionType::clear_bin_outputs() {
  bin_outputs_.Clear();
}
inline const ::TxAck_TransactionType_TxOutputBinType& TxAck_TransactionType::bin_outputs(int index) const {
  // @@protoc_insertion_point(field_get:TxAck.TransactionType.bin_outputs)
  return bin_outputs_.Get(index);
}
inline ::TxAck_TransactionType_TxOutputBinType* TxAck_TransactionType::mutable_bin_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:TxAck.TransactionType.bin_outputs)
  return bin_outputs_.Mutable(index);
}
inline ::TxAck_TransactionType_TxOutputBinType* TxAck_TransactionType::add_bin_outputs() {
  // @@protoc_insertion_point(field_add:TxAck.TransactionType.bin_outputs)
  return bin_outputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TxAck_TransactionType_TxOutputBinType >&
TxAck_TransactionType::bin_outputs() const {
  // @@protoc_insertion_point(field_list:TxAck.TransactionType.bin_outputs)
  return bin_outputs_;
}
inline ::google::protobuf::RepeatedPtrField< ::TxAck_TransactionType_TxOutputBinType >*
TxAck_TransactionType::mutable_bin_outputs() {
  // @@protoc_insertion_point(field_mutable_list:TxAck.TransactionType.bin_outputs)
  return &bin_outputs_;
}

// optional uint32 lock_time = 4;
inline bool TxAck_TransactionType::has_lock_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TxAck_TransactionType::set_has_lock_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TxAck_TransactionType::clear_has_lock_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TxAck_TransactionType::clear_lock_time() {
  lock_time_ = 0u;
  clear_has_lock_time();
}
inline ::google::protobuf::uint32 TxAck_TransactionType::lock_time() const {
  // @@protoc_insertion_point(field_get:TxAck.TransactionType.lock_time)
  return lock_time_;
}
inline void TxAck_TransactionType::set_lock_time(::google::protobuf::uint32 value) {
  set_has_lock_time();
  lock_time_ = value;
  // @@protoc_insertion_point(field_set:TxAck.TransactionType.lock_time)
}

// repeated .TxAck.TransactionType.TxOutputType outputs = 5;
inline int TxAck_TransactionType::outputs_size() const {
  return outputs_.size();
}
inline void TxAck_TransactionType::clear_outputs() {
  outputs_.Clear();
}
inline const ::TxAck_TransactionType_TxOutputType& TxAck_TransactionType::outputs(int index) const {
  // @@protoc_insertion_point(field_get:TxAck.TransactionType.outputs)
  return outputs_.Get(index);
}
inline ::TxAck_TransactionType_TxOutputType* TxAck_TransactionType::mutable_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:TxAck.TransactionType.outputs)
  return outputs_.Mutable(index);
}
inline ::TxAck_TransactionType_TxOutputType* TxAck_TransactionType::add_outputs() {
  // @@protoc_insertion_point(field_add:TxAck.TransactionType.outputs)
  return outputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TxAck_TransactionType_TxOutputType >&
TxAck_TransactionType::outputs() const {
  // @@protoc_insertion_point(field_list:TxAck.TransactionType.outputs)
  return outputs_;
}
inline ::google::protobuf::RepeatedPtrField< ::TxAck_TransactionType_TxOutputType >*
TxAck_TransactionType::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_list:TxAck.TransactionType.outputs)
  return &outputs_;
}

// optional uint32 inputs_cnt = 6;
inline bool TxAck_TransactionType::has_inputs_cnt() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TxAck_TransactionType::set_has_inputs_cnt() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TxAck_TransactionType::clear_has_inputs_cnt() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TxAck_TransactionType::clear_inputs_cnt() {
  inputs_cnt_ = 0u;
  clear_has_inputs_cnt();
}
inline ::google::protobuf::uint32 TxAck_TransactionType::inputs_cnt() const {
  // @@protoc_insertion_point(field_get:TxAck.TransactionType.inputs_cnt)
  return inputs_cnt_;
}
inline void TxAck_TransactionType::set_inputs_cnt(::google::protobuf::uint32 value) {
  set_has_inputs_cnt();
  inputs_cnt_ = value;
  // @@protoc_insertion_point(field_set:TxAck.TransactionType.inputs_cnt)
}

// optional uint32 outputs_cnt = 7;
inline bool TxAck_TransactionType::has_outputs_cnt() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TxAck_TransactionType::set_has_outputs_cnt() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TxAck_TransactionType::clear_has_outputs_cnt() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TxAck_TransactionType::clear_outputs_cnt() {
  outputs_cnt_ = 0u;
  clear_has_outputs_cnt();
}
inline ::google::protobuf::uint32 TxAck_TransactionType::outputs_cnt() const {
  // @@protoc_insertion_point(field_get:TxAck.TransactionType.outputs_cnt)
  return outputs_cnt_;
}
inline void TxAck_TransactionType::set_outputs_cnt(::google::protobuf::uint32 value) {
  set_has_outputs_cnt();
  outputs_cnt_ = value;
  // @@protoc_insertion_point(field_set:TxAck.TransactionType.outputs_cnt)
}

// optional bytes extra_data = 8;
inline bool TxAck_TransactionType::has_extra_data() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TxAck_TransactionType::set_has_extra_data() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TxAck_TransactionType::clear_has_extra_data() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TxAck_TransactionType::clear_extra_data() {
  if (extra_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extra_data_->clear();
  }
  clear_has_extra_data();
}
inline const ::std::string& TxAck_TransactionType::extra_data() const {
  // @@protoc_insertion_point(field_get:TxAck.TransactionType.extra_data)
  return *extra_data_;
}
inline void TxAck_TransactionType::set_extra_data(const ::std::string& value) {
  set_has_extra_data();
  if (extra_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extra_data_ = new ::std::string;
  }
  extra_data_->assign(value);
  // @@protoc_insertion_point(field_set:TxAck.TransactionType.extra_data)
}
inline void TxAck_TransactionType::set_extra_data(const char* value) {
  set_has_extra_data();
  if (extra_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extra_data_ = new ::std::string;
  }
  extra_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:TxAck.TransactionType.extra_data)
}
inline void TxAck_TransactionType::set_extra_data(const void* value, size_t size) {
  set_has_extra_data();
  if (extra_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extra_data_ = new ::std::string;
  }
  extra_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TxAck.TransactionType.extra_data)
}
inline ::std::string* TxAck_TransactionType::mutable_extra_data() {
  set_has_extra_data();
  if (extra_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extra_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TxAck.TransactionType.extra_data)
  return extra_data_;
}
inline ::std::string* TxAck_TransactionType::release_extra_data() {
  clear_has_extra_data();
  if (extra_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = extra_data_;
    extra_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TxAck_TransactionType::set_allocated_extra_data(::std::string* extra_data) {
  if (extra_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete extra_data_;
  }
  if (extra_data) {
    set_has_extra_data();
    extra_data_ = extra_data;
  } else {
    clear_has_extra_data();
    extra_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TxAck.TransactionType.extra_data)
}

// optional uint32 extra_data_len = 9;
inline bool TxAck_TransactionType::has_extra_data_len() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TxAck_TransactionType::set_has_extra_data_len() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TxAck_TransactionType::clear_has_extra_data_len() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TxAck_TransactionType::clear_extra_data_len() {
  extra_data_len_ = 0u;
  clear_has_extra_data_len();
}
inline ::google::protobuf::uint32 TxAck_TransactionType::extra_data_len() const {
  // @@protoc_insertion_point(field_get:TxAck.TransactionType.extra_data_len)
  return extra_data_len_;
}
inline void TxAck_TransactionType::set_extra_data_len(::google::protobuf::uint32 value) {
  set_has_extra_data_len();
  extra_data_len_ = value;
  // @@protoc_insertion_point(field_set:TxAck.TransactionType.extra_data_len)
}

// optional uint32 expiry = 10;
inline bool TxAck_TransactionType::has_expiry() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TxAck_TransactionType::set_has_expiry() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TxAck_TransactionType::clear_has_expiry() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TxAck_TransactionType::clear_expiry() {
  expiry_ = 0u;
  clear_has_expiry();
}
inline ::google::protobuf::uint32 TxAck_TransactionType::expiry() const {
  // @@protoc_insertion_point(field_get:TxAck.TransactionType.expiry)
  return expiry_;
}
inline void TxAck_TransactionType::set_expiry(::google::protobuf::uint32 value) {
  set_has_expiry();
  expiry_ = value;
  // @@protoc_insertion_point(field_set:TxAck.TransactionType.expiry)
}

// optional bool overwintered = 11;
inline bool TxAck_TransactionType::has_overwintered() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TxAck_TransactionType::set_has_overwintered() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TxAck_TransactionType::clear_has_overwintered() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TxAck_TransactionType::clear_overwintered() {
  overwintered_ = false;
  clear_has_overwintered();
}
inline bool TxAck_TransactionType::overwintered() const {
  // @@protoc_insertion_point(field_get:TxAck.TransactionType.overwintered)
  return overwintered_;
}
inline void TxAck_TransactionType::set_overwintered(bool value) {
  set_has_overwintered();
  overwintered_ = value;
  // @@protoc_insertion_point(field_set:TxAck.TransactionType.overwintered)
}

// -------------------------------------------------------------------

// TxAck

// optional .TxAck.TransactionType tx = 1;
inline bool TxAck::has_tx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TxAck::set_has_tx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TxAck::clear_has_tx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TxAck::clear_tx() {
  if (tx_ != NULL) tx_->::TxAck_TransactionType::Clear();
  clear_has_tx();
}
inline const ::TxAck_TransactionType& TxAck::tx() const {
  // @@protoc_insertion_point(field_get:TxAck.tx)
  return tx_ != NULL ? *tx_ : *default_instance_->tx_;
}
inline ::TxAck_TransactionType* TxAck::mutable_tx() {
  set_has_tx();
  if (tx_ == NULL) tx_ = new ::TxAck_TransactionType;
  // @@protoc_insertion_point(field_mutable:TxAck.tx)
  return tx_;
}
inline ::TxAck_TransactionType* TxAck::release_tx() {
  clear_has_tx();
  ::TxAck_TransactionType* temp = tx_;
  tx_ = NULL;
  return temp;
}
inline void TxAck::set_allocated_tx(::TxAck_TransactionType* tx) {
  delete tx_;
  tx_ = tx;
  if (tx) {
    set_has_tx();
  } else {
    clear_has_tx();
  }
  // @@protoc_insertion_point(field_set_allocated:TxAck.tx)
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::TxRequest_RequestType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TxRequest_RequestType>() {
  return ::TxRequest_RequestType_descriptor();
}
template <> struct is_proto_enum< ::TxAck_TransactionType_TxOutputType_OutputScriptType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TxAck_TransactionType_TxOutputType_OutputScriptType>() {
  return ::TxAck_TransactionType_TxOutputType_OutputScriptType_descriptor();
}
template <> struct is_proto_enum< ::InputScriptType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::InputScriptType>() {
  return ::InputScriptType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_messages_2dbitcoin_2eproto__INCLUDED
